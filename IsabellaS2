local GUI = loadstring(game:HttpGet("https://usemoon.xyz/library"))()

local UDimSize
if game:GetService("UserInputService").TouchEnabled then
    UDimSize = UDim2.fromOffset(490, 290)
else
    UDimSize = UDim2.fromOffset(600, 335)
end

local main = GUI:CreateWindow({
    Title = "MOON running in " .. identifyexecutor(),
    SubTitle = "MM2",
    Icon = "moon",
    TabWidth = 50,
    Size = UDimSize,
    Theme = "supernova",
    MinimizeKey = Enum.KeyCode.M
})

local sheriffTab = main:AddTab({ Title = "Sheriff", Icon = "crosshair" })
local murderTab = main:AddTab({ Title = "Murder", Icon = "skull" })
local playerTab = main:AddTab({ Title = "Player", Icon = "user" })
local visualTab = main:AddTab({ Title = "Visual", Icon = "eye" })
local autoFarmTab = main:AddTab({ Title = "Auto Farm", Icon = "zap" })
local settingsTab = main:AddTab({ Title = "Settings", Icon = "settings" })

-- Sistema de funções e conexões
local functions = {}
local connections = {}

-- Função para criar conexões com delay opcional
function functions.createconnection(name, source, callback, delay)
    if connections[name] then
        connections[name]:Disconnect()
    end

    local locked = false

    local function handler(...)
        if delay then
            if locked then return end
            locked = true
            task.delay(delay, function()
                locked = false
            end)
        end
        callback(...)
    end

    local signal =
        typeof(source) == "string" and game:GetService("RunService")[source]
        or typeof(source) == "RBXScriptSignal" and source
        or (type(source) == "table" and source.Connect and source)

    if not signal then
        return nil
    end

    connections[name] = signal:Connect(handler)
    return connections[name]
end

-- Função para fechar conexões
function functions.closeconnection(name)
    if connections[name] then
        connections[name]:Disconnect()
        connections[name] = nil
        return true
    end
    return false
end


-- Configurações Sheriff
local sheriffConfig = {
    showButton = false,
    PingPrediction = true,
    PingSensitivity = 1.18,
    JumpPrediction = true,
    HorizontalMultiplier = 1.00,
    VerticalMultiplier = 1.00,
    MaxPredictionDistance = 350.00,
    VerticalDistanceScale = 2.00,
    LeadTime = 0.01,  -- delay fixo residual (ping já compensa a maior parte)
    XMultiplier = 0.00,
    ZMultiplier = 0.00,
    UnequipAfterShot = false
}

-- Configurações Hitbox
local hitboxConfig = {
    enabled = false,
    size = 10,
    visible = true,
    transparency = 0.5,
    color = Color3.fromRGB(255, 0, 80)
}

-- Configurações ESP
local espConfig = {
    enabled = false,
    innocentColor = Color3.fromHex("#00ff00"),    -- Verde
    sheriffColor = Color3.fromHex("#0026ff"),     -- Azul
    murdererColor = Color3.fromHex("#ff0000"),    -- Vermelho
    nameEnabled = true,
    nameSize = 14,
    gunEnabled = false,
    coinEnabled = false
}

-- Variáveis de estado
local pingCache = 0
local lastPingUpdate = 0
local PING_UPDATE_INTERVAL = 0.15  -- atualiza a cada 150ms (era 500ms — muito lento)

local MY_SPEED = 16
local MY_JUMP = 50
local noclipActive = false

-- Cache ESP
local espConnections = {}
local espRunning = false

-- Variáveis Auto Shot melhoradas
local podeAtirar = true
local delayTiro = 0.3
local delayHolster = 0.0

local autoShotConfig = {
    wallCheck = false
}

local shotStats = {
    totalShots = 0,
    lastShotTime = 0,
    avgDistance = 0
}

-- Velocidade de projétil MM2 (estimada empiricamente)
local BULLET_SPEED = 500  -- studs/segundo — ajustável via slider no menu
-- MM2: valor real estimado entre 400-600. Se errar sempre atrás → aumentar.
-- Se errar sempre na frente → diminuir. Testar com alvo parado.

-- Variáveis do botão na tela
local botaoTela = nil
local botaoArrastavel = false
local tamanhoBot = 80
local savedBotaoPos = UDim2.new(0.85, 0, 0.5, 0)

-- ==================== FUNÇÕES UTILITÁRIAS ====================

local function getPing()
    local currentTime = tick()
    if currentTime - lastPingUpdate > PING_UPDATE_INTERVAL then
        pingCache = game.Players.LocalPlayer:GetNetworkPing() * 1000
        lastPingUpdate = currentTime
    end
    return pingCache
end

local velocityHistory = {}
local accelerationHistory = {}

local function DesequiparArmaRapido()
    local char = game.Players.LocalPlayer.Character
    if not char then return end
    
    local arma = char:FindFirstChild("Gun")
    if arma then
        local hum = char:FindFirstChild("Humanoid")
        if hum then
            hum:UnequipTools()
        end
    end
end

-- ── SISTEMA DE VELOCIDADE COM TIMESTAMP E BUFFER DINÂMICO ──────────
-- Buffer dinâmico: tamanho reduz automaticamente quando detecta speed hack
-- Isso permite convergir em 1-3 frames em vez de 5 quando vel é alta
--
-- Tamanhos e thresholds:
--   vel <= 22 studs/s → buffer 6 (normal, máxima suavização)
--   vel <= 35 studs/s → buffer 4 (correndo rápido)
--   vel >  35 studs/s → buffer 2 (speed hack detectado, reage em 1 frame)
--
-- W_TOTALS: [2]=3, [4]=10, [6]=21
local W_TOTALS = { [2] = 3, [4] = 10, [6] = 21 }

local DIRECTION_CHANGE_THRESHOLD = math.cos(math.rad(55))

local function getBufSize(speed)
    if speed > 35 then return 2
    elseif speed > 22 then return 4
    else return 6 end
end

-- Cada entrada do histórico: { vel=Vector3, t=number }
local function getSmoothedVelocity(hrp)
    local current = hrp.Velocity
    local now     = tick()
    local speed   = Vector2.new(current.X, current.Z).Magnitude
    local bufSize = getBufSize(speed)

    if not velocityHistory[hrp] then
        velocityHistory[hrp] = {}
        for i = 1, bufSize do
            velocityHistory[hrp][i] = { vel = current, t = now - (bufSize - i) * 0.016 }
        end
        accelerationHistory[hrp] = Vector3.new(0, 0, 0)
        return current, false
    end

    local h       = velocityHistory[hrp]
    local prevSize = #h

    -- Redimensiona buffer se a velocidade mudou de faixa (ex: normal → hack)
    -- Não expande de volta imediatamente: mantém buffer pequeno por pelo menos
    -- bufSize frames para não carregar amostras antigas de velocidade menor
    if bufSize < prevSize then
        -- Reduz: mantém só as amostras mais recentes
        local trimmed = {}
        for i = prevSize - bufSize + 1, prevSize do
            trimmed[#trimmed + 1] = h[i]
        end
        velocityHistory[hrp] = trimmed
        h = trimmed
    elseif bufSize > prevSize then
        -- Expande: preenche amostras antigas com a primeira amostra disponível
        local expanded = {}
        local oldest   = h[1]
        for i = 1, bufSize - prevSize do
            expanded[i] = { vel = oldest.vel, t = oldest.t - (bufSize - prevSize - i + 1) * 0.016 }
        end
        for i = 1, prevSize do
            expanded[bufSize - prevSize + i] = h[i]
        end
        velocityHistory[hrp] = expanded
        h = expanded
    end

    -- Detecta mudança brusca de direção (zigzag)
    local lastVel = h[bufSize].vel
    local curXZ   = Vector2.new(current.X, current.Z)
    local lastXZ  = Vector2.new(lastVel.X, lastVel.Z)
    local curMag  = curXZ.Magnitude
    local lastMag = lastXZ.Magnitude

    if curMag > 2 and lastMag > 2 then
        local dot = (curXZ / curMag):Dot(lastXZ / lastMag)
        if dot < DIRECTION_CHANGE_THRESHOLD then
            for i = 1, bufSize do
                h[i] = { vel = current, t = now - (bufSize - i) * 0.016 }
            end
            accelerationHistory[hrp] = Vector3.new(0, 0, 0)
            return current, true
        end
    end

    -- Desloca buffer
    for i = 1, bufSize - 1 do
        h[i] = h[i + 1]
    end
    h[bufSize] = { vel = current, t = now }

    -- Aceleração via regressão linear (least-squares sobre bufSize amostras)
    local sumT, sumVx, sumVz = 0, 0, 0
    local sumT2, sumTVx, sumTVz = 0, 0, 0
    local t0 = h[1].t
    for i = 1, bufSize do
        local dt  = h[i].t - t0
        local vx  = h[i].vel.X
        local vz  = h[i].vel.Z
        sumT   = sumT   + dt
        sumVx  = sumVx  + vx
        sumVz  = sumVz  + vz
        sumT2  = sumT2  + dt * dt
        sumTVx = sumTVx + dt * vx
        sumTVz = sumTVz + dt * vz
    end
    local denom = bufSize * sumT2 - sumT * sumT
    local accelX, accelZ = 0, 0
    if math.abs(denom) > 1e-6 then
        accelX = (bufSize * sumTVx - sumT * sumVx) / denom
        accelZ = (bufSize * sumTVz - sumT * sumVz) / denom
    end
    accelerationHistory[hrp] = Vector3.new(accelX, 0, accelZ)

    -- Velocidade suavizada: média ponderada com pesos 1..bufSize
    local wTotal = W_TOTALS[bufSize] or (bufSize * (bufSize + 1) / 2)
    local sv = Vector3.new(0, 0, 0)
    for i = 1, bufSize do
        sv = sv + h[i].vel * i
    end
    return sv / wTotal, false
end

local function getAcceleration(hrp)
    return accelerationHistory[hrp] or Vector3.new(0, 0, 0)
end

-- Retorna o timestamp da amostra mais recente do buffer (para extrapolação)
local function getLastReplicationTime(hrp)
    local h = velocityHistory[hrp]
    if not h or #h == 0 then return tick() end
    return h[#h].t  -- sempre o último elemento, independente do tamanho
end

-- alvoHRP: HumanoidRootPart (para velocidade/física)
-- alvoAim: Head ou HRP (posição de onde apontar)
local function CalcularPredicaoRapida(alvoHRP, alvoAim, minhaPos)
    if not alvoHRP or not alvoHRP.Parent then return nil end
    if not alvoAim or not alvoAim.Parent then return nil end

    local alvoVelRaw                = alvoHRP.Velocity
    local alvoVelSmooth, dirChanged = getSmoothedVelocity(alvoHRP)
    local alvoAccel                 = getAcceleration(alvoHRP)

    -- EXTRAPOLACAO DE POSICAO E VELOCIDADE ────────────────────────────
    -- O cliente lê HRP.Velocity com ~1-3 frames de atraso (repLag).
    -- Já extrapolamos a posição com vel*repLag.
    -- Agora também extrapolamos a velocidade com accel*repLag:
    --   vel_real ≈ velRaw + accel * repLag
    -- Isso elimina o erro restante quando o murder está acelerando
    -- (saindo do lugar, virando, ou usando speed hack)
    local lastRepTime    = getLastReplicationTime(alvoHRP)
    local repLag         = math.min(tick() - lastRepTime, 0.05)

    -- Velocidade extrapolada: corrige o atraso de replicação
    -- Só X e Z (horizontal): Y não extrapola para não interferir com física de pulo
    local velExtrapX = alvoVelRaw.X + alvoAccel.X * repLag
    local velExtrapZ = alvoVelRaw.Z + alvoAccel.Z * repLag
    local velExtrap  = Vector3.new(velExtrapX, alvoVelRaw.Y, velExtrapZ)

    -- Velocidade base: raw extrapolada ou smooth extrapolada dependendo de zigzag
    -- dirChanged=true: usa velExtrap direta (reação imediata ao zigzag)
    -- dirChanged=false: suaviza X e Z extrapolados (menos jitter em movimento reto)
    local velSmExtrapX = alvoVelSmooth.X + alvoAccel.X * repLag
    local velSmExtrapZ = alvoVelSmooth.Z + alvoAccel.Z * repLag
    local velSmExtrap  = Vector3.new(velSmExtrapX, alvoVelSmooth.Y, velSmExtrapZ)

    local vel = dirChanged and velExtrap or velSmExtrap

    -- Posição extrapolada: usa vel (consistente com o solver)
    -- velExtrap = raw extrapolada; vel = smooth extrapolada (ou raw se zigzag)
    -- A posição de partida usa a mesma vel do solver para evitar inconsistência
    local hrpExtrapolado = alvoHRP.Position + vel * repLag
    local headOffset     = alvoAim.Position - alvoHRP.Position
    local alvoPos        = hrpExtrapolado + headOffset

    local dist = (alvoPos - minhaPos).Magnitude

    -- PING
    local pingTime = 0
    if sheriffConfig.PingPrediction then
        local ping = getPing()
        pingTime = ping * 0.001 * sheriffConfig.PingSensitivity
        if    ping > 150 then pingTime = pingTime * 1.35
        elseif ping > 100 then pingTime = pingTime * 1.2 end
    end

    -- SOLVER ITERATIVO ───────────────────────────────────────────────
    -- Converge totalTime diretamente (inclui pingTime + LeadTime).
    -- Aceleração usa t_voo² (não totalTime²): o alvo acelera pelo tempo
    -- de voo real da bala, não pelo tempo total que inclui ping/lead.
    -- Usar totalTime² superestimava o efeito da aceleração.
    local CONV_STUDS = 0.08
    local extraTime  = pingTime + sheriffConfig.LeadTime
    local horizDist  = Vector2.new(alvoPos.X - minhaPos.X, alvoPos.Z - minhaPos.Z).Magnitude
    local totalTime  = horizDist / BULLET_SPEED + extraTime
    local w_conv     = 0.50

    for i = 0, 7 do
        local w     = math.max(0.40, 0.50 - i * 0.02)  -- decaimento suave: 0.50→0.40
        local t_voo = totalTime - extraTime  -- tempo real de voo da bala
        -- vel*totalTime: onde alvo está em totalTime (movimento linear)
        -- w*accel*t_voo²: contribuição da aceleração durante o voo real
        local futureX = alvoPos.X + vel.X * totalTime + w * alvoAccel.X * t_voo * t_voo
        local futureZ = alvoPos.Z + vel.Z * totalTime + w * alvoAccel.Z * t_voo * t_voo
        local newDist = Vector2.new(futureX - minhaPos.X, futureZ - minhaPos.Z).Magnitude
        local t_new   = newDist / BULLET_SPEED + extraTime
        if math.abs(t_new - totalTime) * BULLET_SPEED < CONV_STUDS then
            w_conv    = w
            totalTime = t_new
            break
        end
        w_conv    = w
        totalTime = t_new
    end

    -- Posição final com t_voo correto
    local t_voo_final = totalTime - extraTime
    local finalX = alvoPos.X + vel.X * totalTime + w_conv * alvoAccel.X * t_voo_final * t_voo_final
    local finalZ = alvoPos.Z + vel.Z * totalTime + w_conv * alvoAccel.Z * t_voo_final * t_voo_final

    -- Anti-shake: alvo quase parado com ruido de aceleracao
    if alvoVelRaw.Magnitude < 3 and alvoAccel.Magnitude > 2 then
        finalX = alvoPos.X + vel.X * totalTime * 0.4
        finalZ = alvoPos.Z + vel.Z * totalTime * 0.4
    end

    -- Fine-tune do usuario aplicado no delta, nao na posicao absoluta
    local deltaX = (finalX - alvoPos.X) * sheriffConfig.HorizontalMultiplier + (sheriffConfig.XMultiplier * 10)
    local deltaZ = (finalZ - alvoPos.Z) * sheriffConfig.HorizontalMultiplier + (sheriffConfig.ZMultiplier * 10)

    -- VERTICAL
    local deltaY  = 0
    -- velY usa SEMPRE raw (não smooth): pulo é impulso instantâneo (0→+52 em 1 frame)
    -- smooth subestimaria velY por até 37 studs/s no frame do pulo → 9 studs de erro
    local velY    = alvoVelRaw.Y
    local gravity = 196.2

    if sheriffConfig.JumpPrediction then
        local hum        = alvoHRP.Parent and alvoHRP.Parent:FindFirstChild("Humanoid")
        local state      = hum and hum:GetState()
        local isAirborne = state == Enum.HumanoidStateType.Freefall
                        or state == Enum.HumanoidStateType.Jumping

        if isAirborne then
            local rayParams = RaycastParams.new()
            rayParams.FilterType = Enum.RaycastFilterType.Blacklist
            rayParams.FilterDescendantsInstances = { alvoHRP.Parent }
            local rayResult = workspace:Raycast(alvoHRP.Position, Vector3.new(0, -50, 0), rayParams)
            local groundDist = rayResult and (alvoHRP.Position.Y - rayResult.Position.Y) or 999

            -- Altura da Head acima do chao quando pousado
            -- = offset atual Head-HRP + altura do HRP acima do chao (~3 studs)
            local headAboveGround = headOffset.Y + 3

            local tPouso = 999
            if velY < 0 then
                local a_eq = 0.5 * gravity
                local b_eq = -velY
                local c_eq = -groundDist
                local disc  = b_eq * b_eq - 4 * a_eq * c_eq
                if disc >= 0 then
                    local r1 = (-b_eq + math.sqrt(disc)) / (2 * a_eq)
                    local r2 = (-b_eq - math.sqrt(disc)) / (2 * a_eq)
                    if r1 > 0 and r2 > 0 then tPouso = math.min(r1, r2)
                    elseif r1 > 0 then tPouso = r1
                    elseif r2 > 0 then tPouso = r2 end
                end
            end

            -- CORREÇÃO DE GRAVIDADE COM REPLAG:
            -- alvoPos.Y já está extrapolado para t=repLag (não t=0).
            -- A gravidade de t=repLag até t=repLag+totalTime é:
            --   velY*T - 0.5*g*[(repLag+T)² - repLag²]
            --   = velY*T - 0.5*g*T² - g*repLag*T
            -- O termo extra "-g*repLag*T" corrige o erro de ~2 studs no pulo.
            local gravCorrection = gravity * repLag * totalTime

            if tPouso < totalTime then
                if rayResult then
                    local groundY = rayResult.Position.Y
                    deltaY = (groundY + headAboveGround) - alvoPos.Y
                else
                    deltaY = (velY * totalTime) - (0.5 * gravity * totalTime * totalTime) - gravCorrection
                end
            else
                deltaY = (velY * totalTime) - (0.5 * gravity * totalTime * totalTime) - gravCorrection
            end

            deltaY = deltaY * sheriffConfig.VerticalMultiplier
        end
    end

    -- Bullet drop separado, nao afetado por VerticalMultiplier
    -- Usa distancia HORIZONTAL (nao 3D): bullet drop depende do tempo de voo
    -- que e determinado pela dist horizontal, nao pela diagonal que inclui Y
    local horizDistDrop = Vector2.new(alvoPos.X - minhaPos.X, alvoPos.Z - minhaPos.Z).Magnitude
    if horizDistDrop > 80 then
        deltaY = deltaY - (horizDistDrop - 80) * 0.008 * sheriffConfig.VerticalDistanceScale
    end

    return Vector3.new(alvoPos.X + deltaX, alvoPos.Y + deltaY, alvoPos.Z + deltaZ)
end


-- ==================== FUNÇÕES AVANÇADAS AUTO SHOT ====================

-- (ballistic solver unificado dentro de CalcularPredicaoRapida)

local function hasLineOfSight(fromPos, toPos)
    if not autoShotConfig.wallCheck then return true end
    
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    rayParams.FilterDescendantsInstances = {game.Players.LocalPlayer.Character}
    
    local result = workspace:Raycast(fromPos, (toPos - fromPos), rayParams)
    
    if result then
        -- Verifica se acertou um jogador
        local hitModel = result.Instance:FindFirstAncestorOfClass("Model")
        if hitModel and game.Players:GetPlayerFromCharacter(hitModel) then
            return true
        end
        return false
    end
    
    return true
end

local function getScoreForTarget(hrp, myPos)
    -- Sistema de pontuação OTIMIZADO para escolher melhor alvo
    local score = 0
    local dist = (hrp.Position - myPos).Magnitude
    
    -- Pontos por proximidade (mais perto = MUITO melhor)
    score = score + (1500 - dist)
    
    -- Pontos por linha de visão (só faz sentido quando wallCheck está ativo)
    if autoShotConfig.wallCheck and hasLineOfSight(myPos, hrp.Position) then
        score = score + 500
    end
    
    -- Penalidade MAIOR por velocidade alta (alvos rápidos são mais difíceis)
    local vel = hrp.Velocity.Magnitude
    score = score - (vel * 5)
    
    -- Bônus se o alvo estiver no chão (mais fácil acertar)
    local hum = hrp.Parent and hrp.Parent:FindFirstChild("Humanoid")
    if hum then
        local state = hum:GetState()
        if state ~= Enum.HumanoidStateType.Freefall and state ~= Enum.HumanoidStateType.Flying then
            score = score + 200
        end
    end
    
    return score
end

local function AcharMelhorAlvo()
    -- SMART TARGETING sempre ativo
    local char = game.Players.LocalPlayer.Character
    if not char then return nil end
    
    local myPos = char:FindFirstChild("HumanoidRootPart")
    if not myPos then return nil end
    myPos = myPos.Position
    
    local bestTarget = nil
    local bestScore = -math.huge
    
    local players = game.Players:GetPlayers()
    for i = 1, #players do
        local v = players[i]
        if v ~= game.Players.LocalPlayer and v.Parent then
            local vChar = v.Character
            if vChar and vChar.Parent then
                local hrp = vChar:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local backpack = v:FindFirstChild("Backpack")
                    if (vChar:FindFirstChild("Knife")) or (backpack and backpack:FindFirstChild("Knife")) then
                        local score = getScoreForTarget(hrp, myPos)
                        if score > bestScore then
                            bestScore = score
                            bestTarget = hrp
                        end
                    end
                end
            end
        end
    end
    
    return bestTarget
end

-- ==================== AUTO SHOT MELHORADO ====================

local equipAttempts = 0  -- previne loop infinito de equip

local function Atirar()
    if not podeAtirar then return end

    local char = game.Players.LocalPlayer.Character
    if not char or not char.Parent then return end

    local hum = char:FindFirstChild("Humanoid")
    if not hum or hum.Health <= 0 then return end

    local head = char:FindFirstChild("Head")
    if not head then return end

    -- ── 1. ACHA O ALVO ──────────────────────────────────────────────
    local alvo = AcharMelhorAlvo()
    if not alvo or not alvo.Parent then return end

    local humAlvo = alvo.Parent:FindFirstChild("Humanoid")
    if not humAlvo or humAlvo.Health <= 0 then return end

    local headAlvo   = alvo.Parent:FindFirstChild("Head")
    local alvoAimPos = headAlvo or alvo

    -- dist calculada da Head do alvo (igual ao alvo de mira real)
    -- antes usava HRP — causava rejeitar alvo válido por +3 studs
    local dist = (alvoAimPos.Position - head.Position).Magnitude
    if dist > sheriffConfig.MaxPredictionDistance then return end

    -- ── 2. WALL CHECK ────────────────────────────────────────────────
    if autoShotConfig.wallCheck and not hasLineOfSight(head.Position, alvo.Position) then
        return
    end

    -- ── 3. EQUIPA A ARMA (máx 3 tentativas — evita loop infinito) ───
    local arma = char:FindFirstChild("Gun")
    if not arma then
        if equipAttempts >= 3 then
            equipAttempts = 0
            return
        end
        local gunInBackpack = game.Players.LocalPlayer.Backpack:FindFirstChild("Gun")
        if not gunInBackpack then equipAttempts = 0; return end

        equipAttempts = equipAttempts + 1
        task.spawn(function()
            hum:EquipTool(gunInBackpack)
            task.wait(0.05)
            if podeAtirar then Atirar() end
        end)
        return
    end
    equipAttempts = 0

    local evento = arma:FindFirstChild("Shoot")
    if not evento then return end

    -- ── 4. EXECUTA O TIRO ────────────────────────────────────────────
    local function executarTiro()
        if not podeAtirar then return end
        if not alvo or not alvo.Parent then return end
        if not humAlvo or humAlvo.Health <= 0 then return end
        if not alvoAimPos or not alvoAimPos.Parent then return end

        local posPredicao = CalcularPredicaoRapida(alvo, alvoAimPos, head.Position)
        if not posPredicao then return end

        if (posPredicao - alvoAimPos.Position).Magnitude > 40 then
            posPredicao = alvoAimPos.Position
        end

        evento:FireServer(CFrame.new(head.Position, posPredicao), CFrame.new(posPredicao))

        podeAtirar = false

        -- dist recalculada no momento real do tiro (alvo pode ter se movido durante apex)
        local distAtual = (alvoAimPos.Position - head.Position).Magnitude
        local adaptiveDelay
        if distAtual < 50 then
            adaptiveDelay = delayTiro * 0.7
        elseif distAtual < 120 then
            adaptiveDelay = delayTiro
        elseif distAtual < 220 then
            adaptiveDelay = delayTiro * 1.3
        else
            adaptiveDelay = delayTiro * 1.6
        end
        task.delay(adaptiveDelay, function() podeAtirar = true end)

        if sheriffConfig.UnequipAfterShot then
            task.delay(delayHolster > 0 and delayHolster or 0.05, DesequiparArmaRapido)
        end
    end

    -- ── 5. APEX DETECTION ────────────────────────────────────────────
    local stateAlvo = humAlvo:GetState()
    local velYAlvo  = alvo.Velocity.Y
    local noApex    = (stateAlvo == Enum.HumanoidStateType.Freefall
                    or stateAlvo == Enum.HumanoidStateType.Jumping)
                   and math.abs(velYAlvo) < 8

    if noApex then
        podeAtirar = false
        local apexConn
        -- Timeout garante que podeAtirar SEMPRE volta para true
        -- Antes: se apexConn falhasse, podeAtirar ficava false para sempre
        local timeoutHandle = task.delay(0.12, function()
            if apexConn then apexConn:Disconnect(); apexConn = nil end
            podeAtirar = true
            executarTiro()
        end)
        apexConn = game:GetService("RunService").Heartbeat:Connect(function()
            if not apexConn then return end
            -- Alvo sumiu durante espera: libera sem atirar
            if not alvo or not alvo.Parent then
                apexConn:Disconnect(); apexConn = nil
                task.cancel(timeoutHandle)
                podeAtirar = true
                return
            end
            if alvo.Velocity.Y < -5 then
                apexConn:Disconnect(); apexConn = nil
                task.cancel(timeoutHandle)
                podeAtirar = true
                executarTiro()
            end
        end)
    else
        executarTiro()
    end
end

-- ==================== BOTÃO NA TELA AUTO SHOT ====================

local function CriarBotaoTela()
    if botaoTela then return end

    local sg = Instance.new("ScreenGui")
    sg.Name = "SilentAimBtnUltra"
    sg.ResetOnSpawn = false
    sg.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    sg.IgnoreGuiInset = true

    local container = Instance.new("Frame")
    container.Name = "MainContainer"
    container.Size = UDim2.new(0, tamanhoBot, 0, tamanhoBot)
    container.Position = savedBotaoPos
    container.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    container.BackgroundTransparency = 0.3
    container.BorderSizePixel = 0
    container.Parent = sg

    local containerCorner = Instance.new("UICorner")
    containerCorner.CornerRadius = UDim.new(0, 12)
    containerCorner.Parent = container

    local outerCircle = Instance.new("Frame")
    outerCircle.Name = "OuterCircle"
    outerCircle.Size = UDim2.new(0, tamanhoBot * 0.6, 0, tamanhoBot * 0.6)
    outerCircle.Position = UDim2.new(0.5, 0, 0.5, 0)
    outerCircle.AnchorPoint = Vector2.new(0.5, 0.5)
    outerCircle.BackgroundTransparency = 1
    outerCircle.BorderSizePixel = 0
    outerCircle.Parent = container

    local outerStroke = Instance.new("UIStroke")
    outerStroke.Color = Color3.fromRGB(255, 255, 255)
    outerStroke.Thickness = 3
    outerStroke.Parent = outerCircle

    Instance.new("UICorner", outerCircle).CornerRadius = UDim.new(1, 0)

    local centerDot = Instance.new("Frame")
    centerDot.Name = "CenterDot"
    centerDot.Size = UDim2.new(0, tamanhoBot * 0.15, 0, tamanhoBot * 0.15)
    centerDot.Position = UDim2.new(0.5, 0, 0.5, 0)
    centerDot.AnchorPoint = Vector2.new(0.5, 0.5)
    centerDot.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    centerDot.BorderSizePixel = 0
    centerDot.Parent = container
    Instance.new("UICorner", centerDot).CornerRadius = UDim.new(1, 0)

    local function createAimLine(name, rotation, xOffset, yOffset)
        local line = Instance.new("Frame")
        line.Name = name
        line.Size = UDim2.new(0, 3, 0, tamanhoBot * 0.12)
        line.Position = UDim2.new(0.5, xOffset, 0.5, yOffset)
        line.AnchorPoint = Vector2.new(0.5, 0.5)
        line.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        line.BorderSizePixel = 0
        line.Rotation = rotation
        line.Parent = container
        Instance.new("UICorner", line).CornerRadius = UDim.new(1, 0)
    end

    createAimLine("TopLine",    0,    0,              -(tamanhoBot * 0.25))
    createAimLine("BottomLine", 0,    0,               (tamanhoBot * 0.25))
    createAimLine("LeftLine",   90, -(tamanhoBot * 0.25), 0)
    createAimLine("RightLine",  90,  (tamanhoBot * 0.25), 0)

    local btn = Instance.new("TextButton")
    btn.Name = "ClickButton"
    btn.Size = UDim2.new(1, 0, 1, 0)
    btn.BackgroundTransparency = 1
    btn.Text = ""
    btn.AutoButtonColor = false
    btn.Parent = container

    -- Feedback visual ao pressionar
    local function setPressed(on)
        container.BackgroundTransparency = on and 0.05 or 0.3
        outerStroke.Color = on and Color3.fromRGB(255, 80, 80) or Color3.fromRGB(255, 255, 255)
    end

    -- HOLD: pressionar inicia o auto shot, soltar para
    local lastClickTime = 0
    btn.InputBegan:Connect(function(input)
        local isTouch = input.UserInputType == Enum.UserInputType.Touch
        local isMouse = input.UserInputType == Enum.UserInputType.MouseButton1

        if isTouch or isMouse then
            if botaoArrastavel then
                -- Modo arraste: não dispara, só move
                local startPos = input.Position
                local startFrame = container.Position
                local moved = false

                local moveConn, endConn
                moveConn = game:GetService("UserInputService").InputChanged:Connect(function(inp)
                    if inp == input or inp.UserInputType == Enum.UserInputType.MouseMovement then
                        local delta = inp.Position - startPos
                        if delta.Magnitude > 5 then moved = true end
                        container.Position = UDim2.new(
                            startFrame.X.Scale,
                            startFrame.X.Offset + delta.X,
                            startFrame.Y.Scale,
                            startFrame.Y.Offset + delta.Y
                        )
                    end
                end)

                endConn = input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        savedBotaoPos = container.Position
                        moveConn:Disconnect()
                        endConn:Disconnect()
                    end
                end)
            else
                -- Modo disparo: tiro único ao pressionar
                local success, errorMsg = pcall(function()
                    setPressed(true)
                    Atirar()
                    task.delay(0.1, function() setPressed(false) end)
                end)
                
                if not success then
                    setPressed(false)
                    warn("Button Shot Error:", errorMsg)
                end
            end
        end
    end)

    sg.Parent = game:GetService("CoreGui")
    botaoTela = sg
end

local function RemoverBotaoTela()
    if botaoTela then
        botaoTela:Destroy()
        botaoTela = nil
    end
end

local function AtualizarTamanhoBotao()
    if not botaoTela then return end
    local container = botaoTela:FindFirstChild("MainContainer")
    if not container then return end

    container.Size = UDim2.new(0, tamanhoBot, 0, tamanhoBot)

    local outerCircle = container:FindFirstChild("OuterCircle")
    if outerCircle then
        outerCircle.Size = UDim2.new(0, tamanhoBot * 0.6, 0, tamanhoBot * 0.6)
    end

    local centerDot = container:FindFirstChild("CenterDot")
    if centerDot then
        centerDot.Size = UDim2.new(0, tamanhoBot * 0.15, 0, tamanhoBot * 0.15)
    end

    local lines = {
        { name = "TopLine",    xOff = 0,                  yOff = -(tamanhoBot * 0.25) },
        { name = "BottomLine", xOff = 0,                  yOff =  (tamanhoBot * 0.25) },
        { name = "LeftLine",   xOff = -(tamanhoBot * 0.25), yOff = 0                  },
        { name = "RightLine",  xOff =  (tamanhoBot * 0.25), yOff = 0                  },
    }
    for _, d in ipairs(lines) do
        local line = container:FindFirstChild(d.name)
        if line then
            line.Size = UDim2.new(0, 3, 0, tamanhoBot * 0.12)
            line.Position = UDim2.new(0.5, d.xOff, 0.5, d.yOff)
        end
    end
end

-- ==================== HITBOX SYSTEM ====================
-- Abordagem: Part SEPARADA no workspace (não modifica o HRP).
local hitboxParts = {}
local hitboxConnections = {}
local originalSizes = {}

local function createHitboxForPlayer(player)
    if player == game.Players.LocalPlayer then return end
    if not player.Character then return end

    local character = player.Character
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local playerName = player.Name

    if not originalSizes[playerName] then
        originalSizes[playerName] = hrp.Size
    end

    hrp.Size = Vector3.new(hitboxConfig.size, hitboxConfig.size, hitboxConfig.size)
    hrp.Transparency = 0.9
    hrp.Material = Enum.Material.ForceField
    hrp.CanCollide = false

    local oldVisual = hrp:FindFirstChild("HitboxVisual")
    if oldVisual then oldVisual:Destroy() end

    if hitboxConfig.visible then
        local box = Instance.new("BoxHandleAdornment")
        box.Name = "HitboxVisual"
        box.Adornee = hrp
        box.Size = hrp.Size
        box.Color3 = hitboxConfig.color
        box.Transparency = hitboxConfig.transparency
        box.AlwaysOnTop = true
        box.ZIndex = 1
        box.Parent = hrp
    end

    hitboxParts[playerName] = hrp
end

local function updateAllHitboxes()
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer and player.Character then
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local newSize = Vector3.new(hitboxConfig.size, hitboxConfig.size, hitboxConfig.size)
                if hrp.Size ~= newSize then
                    hrp.Size = newSize
                    hrp.Transparency = 0.9
                    hrp.Material = Enum.Material.ForceField
                    hrp.CanCollide = false
                end
                local visual = hrp:FindFirstChild("HitboxVisual")
                if hitboxConfig.visible then
                    if not visual then
                        visual = Instance.new("BoxHandleAdornment")
                        visual.Name = "HitboxVisual"
                        visual.Adornee = hrp
                        visual.AlwaysOnTop = true
                        visual.ZIndex = 1
                        visual.Parent = hrp
                    end
                    visual.Size = hrp.Size
                    visual.Color3 = hitboxConfig.color
                    visual.Transparency = hitboxConfig.transparency
                else
                    if visual then visual:Destroy() end
                end
            else
                createHitboxForPlayer(player)
            end
        end
    end
end

local function startHitbox()
    -- Cria hitbox para todos os jogadores atuais
    for _, player in ipairs(game.Players:GetPlayers()) do
        createHitboxForPlayer(player)
    end
    
    -- Monitora novos jogadores
    hitboxConnections.playerAdded = game.Players.PlayerAdded:Connect(function(player)
        -- Salva a conexão para que stopHitbox() possa desconectar
        hitboxConnections[player.Name] = player.CharacterAdded:Connect(function()
            task.wait(0.5)
            if hitboxConfig.enabled then
                createHitboxForPlayer(player)
            end
        end)
    end)
    
    -- Monitora respawn de jogadores existentes
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            hitboxConnections[player.Name] = player.CharacterAdded:Connect(function()
                task.wait(0.5)
                if hitboxConfig.enabled then
                    createHitboxForPlayer(player)
                end
            end)
        end
    end
    
    -- Loop de manutenção throttled: 10x/s em vez de 60x/s
    -- Rodar updateAllHitboxes todo frame causava travamentos (GetPlayers + iteração a 60fps)
    local lastHitboxUpdate = 0
    hitboxConnections.heartbeat = game:GetService("RunService").Heartbeat:Connect(function()
        if not hitboxConfig.enabled then return end
        local now = tick()
        if now - lastHitboxUpdate < 0.1 then return end
        lastHitboxUpdate = now
        updateAllHitboxes()
    end)
    
    -- Cleanup quando jogador sai
    hitboxConnections.playerRemoving = game.Players.PlayerRemoving:Connect(function(player)
        local playerName = player.Name
        
        if hitboxParts[playerName] and hitboxParts[playerName].Parent then
            local hrp = hitboxParts[playerName]
            pcall(function()
                local visual = hrp:FindFirstChild("HitboxVisual")
                if visual then visual:Destroy() end
                hrp.Size = originalSizes[playerName] or Vector3.new(2, 2, 1)
                hrp.Transparency = 1
            end)
        end

        originalSizes[playerName] = nil
        hitboxParts[playerName]   = nil
        
        if hitboxConnections[playerName] then
            hitboxConnections[playerName]:Disconnect()
            hitboxConnections[playerName] = nil
        end
    end)
end

local function stopHitbox()
    -- Desconecta todos os eventos (incluindo nested connections)
    for name, conn in pairs(hitboxConnections) do
        if conn then
            pcall(function() 
                if typeof(conn) == "RBXScriptConnection" then
                    conn:Disconnect()
                end
            end)
        end
    end
    hitboxConnections = {}
    
    -- Restaura todos os HRPs ao tamanho original
    for playerName, hrp in pairs(hitboxParts) do
        if hrp and hrp.Parent then
            pcall(function()
                local visual = hrp:FindFirstChild("HitboxVisual")
                if visual then visual:Destroy() end
                hrp.Size = originalSizes[playerName] or Vector3.new(2, 2, 1)
                hrp.Transparency = 1
                hrp.CanCollide = false
            end)
        end
    end

    hitboxParts = {}
    originalSizes = {}
end

-- ==================== ESP SYSTEM (PLAYER) ====================

local function CreateESP(targetPlayer)
    if targetPlayer == game.Players.LocalPlayer then return end

    local function ApplyESP(character)
        if not character then return end

        local root = character:WaitForChild("HumanoidRootPart", 3)
        if not root then return end

        -- ESTRATÉGIA FINAL: Highlight no character com Adornee = character.
        -- Para evitar que o HRP expandido (hitbox) distorça o contorno,
        -- usamos LocalTransparencyModifier=1 no HRP enquanto o Highlight está ativo.
        -- Isso exclui o HRP do bounding box do Highlight sem afetar o hitbox real.
        -- O HRP continua com o tamanho expandido para colisão — só o Highlight o ignora.
        local highlight = character:FindFirstChild("MoonHighlight") or Instance.new("Highlight")
        highlight.Name            = "MoonHighlight"
        highlight.Parent          = character
        highlight.Adornee         = character
        highlight.FillTransparency    = 1
        highlight.OutlineTransparency = 0
        highlight.DepthMode       = Enum.HighlightDepthMode.AlwaysOnTop

        -- Esconde o HRP do Highlight via LocalTransparencyModifier
        -- (não afeta física nem o hitbox — só visual para o cliente local)
        root.LocalTransparencyModifier = 1

        local bodyModel = nil  -- sem model auxiliar nessa abordagem
        
        -- 2. Tag com nome do player
        local tag = root:FindFirstChild("MoonTag") or Instance.new("BillboardGui")
        tag.Name = "MoonTag"
        tag.Size = UDim2.new(0, 200, 0, 50)
        tag.AlwaysOnTop = true
        tag.StudsOffset = Vector3.new(0, 3.5, 0)
        tag.Parent = root
        
        local label = tag:FindFirstChild("Label") or Instance.new("TextLabel")
        label.Name = "Label"
        label.Parent = tag
        label.BackgroundTransparency = 1
        label.Size = UDim2.new(1, 0, 1, 0)
        label.Text = targetPlayer.Name
        label.Font = Enum.Font.GothamBold
        label.TextSize = espConfig.nameSize
        label.TextStrokeTransparency = 0
        label.TextScaled = false
        
        -- Loop de atualização de cores e visibilidade (throttled: ~10x/s, não 60x/s)
        local updateConnection
        local lastESPUpdate = 0
        updateConnection = game:GetService("RunService").Heartbeat:Connect(function()
            local now = tick()
            if now - lastESPUpdate < 0.1 then return end
            lastESPUpdate = now

            if not character or not character.Parent then
                if updateConnection then
                    updateConnection:Disconnect()
                end
                return
            end
            
            if not espConfig.enabled then return end
            
            local color = espConfig.innocentColor
            
            -- Checar inventário para determinar role
            local backpack = targetPlayer:FindFirstChild("Backpack")
            local hasKnife = (backpack and backpack:FindFirstChild("Knife")) or character:FindFirstChild("Knife")
            local hasGun = (backpack and backpack:FindFirstChild("Gun")) or character:FindFirstChild("Gun")
            
            if hasKnife then
                color = espConfig.murdererColor
            elseif hasGun then
                color = espConfig.sheriffColor
            end
            
            -- Aplicar cor no highlight
            highlight.OutlineColor = color
            label.TextColor3 = color
            label.Text = targetPlayer.Name
            label.TextSize = espConfig.nameSize
            
            -- Controlar visibilidade do nome
            tag.Enabled = espConfig.nameEnabled and espConfig.enabled
        end)
        
        -- Salvar conexão para cleanup
        table.insert(espConnections, {
            player = targetPlayer,
            connection = updateConnection,
            highlight = highlight,
            tag = tag,
            bodyModel = bodyModel
        })
    end
    
    -- Aplicar ESP ao personagem atual
    if targetPlayer.Character then
        ApplyESP(targetPlayer.Character)
    end
    
    -- Conectar evento de personagem adicionado
    local charConnection = targetPlayer.CharacterAdded:Connect(ApplyESP)
    table.insert(espConnections, {
        player = targetPlayer,
        connection = charConnection,
        charConnection = true
    })
end

local function enablePlayerESP()
    if espRunning then return end
    espRunning = true
    espConfig.enabled = true
    
    -- Limpar conexões antigas
    for _, conn in pairs(espConnections) do
        if conn.connection and conn.connection.Connected then
            conn.connection:Disconnect()
        end
        if conn.highlight then
            conn.highlight:Destroy()
        end
        if conn.tag then
            conn.tag:Destroy()
        end
    end
    espConnections = {}
    
    -- Criar ESP para todos os players
    for _, plr in pairs(game.Players:GetPlayers()) do
        CreateESP(plr)
    end
    
    -- Conectar novo jogador
    local playerAddedConnection = game.Players.PlayerAdded:Connect(CreateESP)
    table.insert(espConnections, {connection = playerAddedConnection})
    
    -- Conectar jogador removido
    local playerRemovingConnection = game.Players.PlayerRemoving:Connect(function(plr)
        -- Limpar ESP do jogador removido
        for i = #espConnections, 1, -1 do
            local conn = espConnections[i]
            if conn.player == plr then
                if conn.connection and conn.connection.Connected then
                    conn.connection:Disconnect()
                end
                if conn.highlight then
                    conn.highlight:Destroy()
                end
                if conn.tag then
                    conn.tag:Destroy()
                end
                table.remove(espConnections, i)
            end
        end
    end)
    table.insert(espConnections, {connection = playerRemovingConnection})
end

local function disablePlayerESP()
    espRunning = false
    espConfig.enabled = false
    
    -- Desconectar todas as conexões
    for _, conn in pairs(espConnections) do
        if conn.connection and conn.connection.Connected then
            conn.connection:Disconnect()
        end
        -- highlight/tag/bodyModel podem ter sido destruídos junto com o character
        if conn.highlight and conn.highlight.Parent then
            conn.highlight:Destroy()
        end
        if conn.tag and conn.tag.Parent then
            conn.tag:Destroy()
        end
        -- Restaura LocalTransparencyModifier do HRP se ainda existir
        if conn.player and conn.player.Character then
            local hrp = conn.player.Character:FindFirstChild("HumanoidRootPart")
            if hrp then hrp.LocalTransparencyModifier = 0 end
        end
    end
    espConnections = {}
    
    -- Limpar ESP manualmente de todos os jogadores
    for _, plr in pairs(game.Players:GetPlayers()) do
        if plr.Character then
            local highlight = plr.Character:FindFirstChild("MoonHighlight")
            if highlight then highlight:Destroy() end

            local root = plr.Character:FindFirstChild("HumanoidRootPart")
            if root then
                local tag = root:FindFirstChild("MoonTag")
                if tag then tag:Destroy() end
                -- Restaura LocalTransparencyModifier
                root.LocalTransparencyModifier = 0
            end
        end
    end
end

-- ==================== ESP GUN (portado do Sun_Main) ====================

local gunESPConnection = nil

local function applyGunESP(v)
    if v.Name ~= "GunDrop" then return end
    if not v:FindFirstChild("GunESP_Highlight") then
        local highlight = Instance.new("Highlight")
        highlight.Name = "GunESP_Highlight"
        highlight.Parent = v
        highlight.FillColor = Color3.fromRGB(255, 255, 0)
        highlight.OutlineColor = Color3.new(1, 1, 1)
        highlight.FillTransparency = 0.5
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    end
    if not v:FindFirstChild("GunESP_Name") then
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "GunESP_Name"
        billboard.Parent = v
        billboard.AlwaysOnTop = true
        billboard.Size = UDim2.new(0, 100, 0, 50)
        billboard.StudsOffset = Vector3.new(0, 2, 0)
        local label = Instance.new("TextLabel")
        label.Parent = billboard
        label.BackgroundTransparency = 1
        label.Size = UDim2.new(1, 0, 1, 0)
        label.Text = "GUN"
        label.TextColor3 = Color3.fromRGB(255, 255, 0)
        label.TextStrokeTransparency = 0
        label.TextSize = 14
        label.Font = Enum.Font.SourceSansBold
    end
end

local function enableGunESP()
    if gunESPConnection then return end
    -- Aplica nas armas já existentes
    for _, v in pairs(workspace:GetDescendants()) do
        applyGunESP(v)
    end
    -- Detecta novas armas via evento (sem loop pesado)
    gunESPConnection = functions.createconnection("GunESP_Loop", workspace.DescendantAdded, function(v)
        if espConfig.gunEnabled then
            applyGunESP(v)
        end
    end)
end

local function disableGunESP()
    espConfig.gunEnabled = false
    functions.closeconnection("GunESP_Loop")
    gunESPConnection = nil
    for _, v in pairs(workspace:GetDescendants()) do
        if v:FindFirstChild("GunESP_Highlight") then v.GunESP_Highlight:Destroy() end
        if v:FindFirstChild("GunESP_Name") then v.GunESP_Name:Destroy() end
    end
end

-- ==================== ESP COIN (portado do Sun_Main) ====================

local coinESPConnection = nil

local function aplicarCoinESP(objeto)
    if objeto:FindFirstChild("Coin_XRAY") then return end
    local adorn = Instance.new("BoxHandleAdornment")
    adorn.Name = "Coin_XRAY"
    adorn.AlwaysOnTop = true
    adorn.Adornee = objeto
    adorn.ZIndex = 5
    adorn.Size = objeto.Size
    adorn.Color3 = Color3.fromRGB(255, 215, 0)
    adorn.Transparency = 0.6
    adorn.Parent = objeto
    objeto.AncestryChanged:Connect(function(_, parent)
        if not parent then adorn:Destroy() end
    end)
end

local function enableCoinESP()
    if coinESPConnection then return end
    -- Aplica nas moedas já existentes
    for _, v in pairs(workspace:GetDescendants()) do
        if v.Name == "Coin_Server" and v:IsA("BasePart") then
            aplicarCoinESP(v)
        end
    end
    -- Detecta novas moedas via evento
    coinESPConnection = functions.createconnection("CoinESP_Added", workspace.DescendantAdded, function(new)
        if espConfig.coinEnabled and new.Name == "Coin_Server" and new:IsA("BasePart") then
            aplicarCoinESP(new)
        end
    end)
end

local function disableCoinESP()
    espConfig.coinEnabled = false
    functions.closeconnection("CoinESP_Added")
    coinESPConnection = nil
    for _, v in pairs(workspace:GetDescendants()) do
        if v:FindFirstChild("Coin_XRAY") then v.Coin_XRAY:Destroy() end
    end
end

-- ==================== NOCLIP ====================

local noclipParts = {}  -- cache das parts do personagem para noclip

local function cacheNoclipParts()
    noclipParts = {}
    local char = game.Players.LocalPlayer.Character
    if not char then return end
    for _, part in pairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            noclipParts[#noclipParts + 1] = part
        end
    end
end

local function startNoClip()
    noclipActive = true
    cacheNoclipParts()  -- cacheia parts uma vez só, não todo frame

    functions.createconnection("NoClip", "Stepped", function()
        if not noclipActive then return end
        -- Usa cache: zero alocações por frame
        for i = 1, #noclipParts do
            local part = noclipParts[i]
            if part and part.Parent then
                part.CanCollide = false
            end
        end
    end)
end

local function stopNoClip()
    noclipActive = false
    functions.closeconnection("NoClip")
    for i = 1, #noclipParts do
        local part = noclipParts[i]
        if part and part.Parent then
            part.CanCollide = true
        end
    end
    noclipParts = {}
end

-- ==================== SPEED & JUMP ====================

local function setSpeed(value)
    MY_SPEED = value
    
    local char = game.Players.LocalPlayer.Character
    if char then
        local humanoid = char:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = value
        end
    end
end

local function setJump(value)
    MY_JUMP = value
    
    local char = game.Players.LocalPlayer.Character
    if char then
        local humanoid = char:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.JumpPower = value
        end
    end
end

-- Monitora quando o jogo reseta WalkSpeed/JumpPower (ex: MM2 reseta ao puxar faca)
-- e reaplica imediatamente os valores configurados
local speedWatchConn = nil
local jumpWatchConn  = nil

local function hookHumanoidStats(humanoid)
    if speedWatchConn then speedWatchConn:Disconnect() end
    if jumpWatchConn  then jumpWatchConn:Disconnect()  end

    speedWatchConn = humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
        if MY_SPEED ~= 16 and humanoid.WalkSpeed ~= MY_SPEED then
            humanoid.WalkSpeed = MY_SPEED
        end
    end)
    jumpWatchConn = humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
        if MY_JUMP ~= 50 and humanoid.JumpPower ~= MY_JUMP then
            humanoid.JumpPower = MY_JUMP
        end
    end)
end

-- ==================== ANTI-AFK ====================

local antiAFKActive = false
local antiAFKConnection = nil

local function startAntiAFK()
    antiAFKActive = true
    local VU = game:GetService("VirtualUser")
    antiAFKConnection = game.Players.LocalPlayer.Idled:Connect(function()
        VU:CaptureController()
        VU:ClickButton2(Vector2.new())
    end)
end

local function stopAntiAFK()
    antiAFKActive = false
    if antiAFKConnection then
        antiAFKConnection:Disconnect()
        antiAFKConnection = nil
    end
end

-- ==================== CONFIGURAÇÃO DAS ABAS ====================

-- ==================== SHERIFF TAB ====================
do
    sheriffTab:AddSection("Shot Configuration")

    sheriffTab:AddKeybind("AutoShotKeybind", {
        Title = "Auto Shot Hotkey",
        Description = "Press to shoot once",
        Default = "E",
        Callback = function()
            local success, errorMsg = pcall(function()
                Atirar()
            end)
            
            if not success then
                warn("Hotkey Shot Error:", errorMsg)
            end
        end
    })
    
    sheriffTab:AddDropdown("ShotSpeed", {
        Title = "Shot Speed",
        Description = "Change fire rate delay",
        Values = {"Fast", "Medium", "Slow"},
        Default = "Medium",
        Callback = function(value)
            if value == "Fast" then
                delayTiro = 0.15
            elseif value == "Medium" then
                delayTiro = 0.3
            else
                delayTiro = 0.5
            end
        end
    })
    
    sheriffTab:AddToggle("UnequipAfterShot", {
        Title = "Unequip After Shot",
        Description = "Auto-unequip weapon after shooting",
        Default = false,
        Callback = function(value)
            sheriffConfig.UnequipAfterShot = value
        end
    })
    
    sheriffTab:AddSlider("HolsterDelay", {
        Title = "Holster Delay",
        Description = "Delay before unequipping (seconds)",
        Default = 0.0,
        Min = 0.0,
        Max = 2.0,
        Rounding = 2,
        Callback = function(value)
            delayHolster = value
        end
    })
    
    sheriffTab:AddSection("On-Screen Button")
    
    sheriffTab:AddToggle("ShowButton", {
        Title = "Show Auto Shot Button",
        Description = "Display button on screen to shoot",
        Default = false,
        Callback = function(value)
            sheriffConfig.showButton = value
            if value then
                CriarBotaoTela()
            else
                RemoverBotaoTela()
            end
        end
    })
    
    sheriffTab:AddToggle("DraggableButton", {
        Title = "Draggable Button",
        Description = "Enable to move the button around",
        Default = false,
        Callback = function(value)
            botaoArrastavel = value
        end
    })
    
    sheriffTab:AddSlider("ButtonSize", {
        Title = "Button Size",
        Description = "Adjust the button size",
        Default = 80,
        Min = 50,
        Max = 150,
        Rounding = 0,
        Callback = function(value)
            tamanhoBot = value
            AtualizarTamanhoBotao()
        end
    })
    
    sheriffTab:AddSection("Advanced Targeting")
    
    sheriffTab:AddToggle("WallCheck", {
        Title = "Wall Check",
        Description = "Only shoot if target is visible (no walls blocking)",
        Default = false,
        Callback = function(value)
            autoShotConfig.wallCheck = value
        end
    })
    
    sheriffTab:AddSection("Prediction Settings")

    sheriffTab:AddToggle("PingPrediction", {
        Title = "Ping Prediction",
        Description = "Compensate for network latency",
        Default = true,
        Callback = function(value)
            sheriffConfig.PingPrediction = value
        end
    })

    sheriffTab:AddSlider("PingSensitivity", {
        Title = "Ping Sensitivity",
        Description = "Adjust ping compensation",
        Default = 1.18,
        Min = 0.5,
        Max = 2.0,
        Rounding = 2,
        Callback = function(value)
            sheriffConfig.PingSensitivity = value
        end
    })

    sheriffTab:AddToggle("JumpPrediction", {
        Title = "Jump Prediction",
        Description = "Compensate when target is airborne",
        Default = true,
        Callback = function(value)
            sheriffConfig.JumpPrediction = value
        end
    })

    sheriffTab:AddSlider("HorizontalMultiplier", {
        Title = "Horizontal Multiplier",
        Description = "Adjust horizontal prediction strength",
        Default = 1.00,
        Min = 0.1,
        Max = 2.0,
        Rounding = 2,
        Callback = function(value)
            sheriffConfig.HorizontalMultiplier = value
        end
    })

    sheriffTab:AddSlider("VerticalMultiplier", {
        Title = "Vertical Multiplier",
        Description = "Adjust vertical prediction strength",
        Default = 1.00,
        Min = 0.1,
        Max = 2.0,
        Rounding = 2,
        Callback = function(value)
            sheriffConfig.VerticalMultiplier = value
        end
    })

    sheriffTab:AddSlider("LeadTime", {
        Title = "Lead Time",
        Description = "Offset fixo alem do ping (0 = so ping)",
        Default = 0.01,
        Min = 0.00,
        Max = 0.15,
        Rounding = 2,
        Callback = function(value)
            sheriffConfig.LeadTime = value
        end
    })

    sheriffTab:AddSlider("BulletSpeed", {
        Title = "Bullet Speed",
        Description = "Velocidade do projetil (studs/s). Errou atras = aumentar, errou na frente = diminuir",
        Default = 500,
        Min = 300,
        Max = 800,
        Rounding = 0,
        Callback = function(value)
            BULLET_SPEED = value
        end
    })

    sheriffTab:AddSlider("VerticalDistanceScale", {
        Title = "Vertical Distance Scale",
        Description = "Vertical adjustment for long range",
        Default = 2.00,
        Min = 1,
        Max = 20,
        Rounding = 2,
        Callback = function(value)
            sheriffConfig.VerticalDistanceScale = value
        end
    })

    sheriffTab:AddSlider("MaxDistance", {
        Title = "Max Prediction Distance",
        Description = "Maximum distance for prediction",
        Default = 350,
        Min = 100,
        Max = 500,
        Rounding = 0,
        Callback = function(value)
            sheriffConfig.MaxPredictionDistance = value
        end
    })

    sheriffTab:AddSlider("XMultiplier", {
        Title = "X Multiplier",
        Description = "Fine-tune X axis offset",
        Default = 0.00,
        Min = -1.0,
        Max = 1.0,
        Rounding = 2,
        Callback = function(value)
            sheriffConfig.XMultiplier = value
        end
    })

    sheriffTab:AddSlider("ZMultiplier", {
        Title = "Z Multiplier",
        Description = "Fine-tune Z axis offset",
        Default = 0.00,
        Min = -1.0,
        Max = 1.0,
        Rounding = 2,
        Callback = function(value)
            sheriffConfig.ZMultiplier = value
        end
    })
end

-- ==================== MURDER TAB ====================
do
    murderTab:AddSection("Murder Tools")
    
    murderTab:AddSection("Hitbox Expander")
    
    murderTab:AddToggle("ExpandHitbox", {
        Title = "Expand Hitboxes",
        Description = "Enlarge player hitboxes for easier hits",
        Default = false,
        Callback = function(value)
            hitboxConfig.enabled = value
            if value then
                startHitbox()
            else
                stopHitbox()
            end
        end
    })
    
    murderTab:AddSlider("HitboxSize", {
        Title = "Hitbox Size",
        Description = "Size of the expanded hitbox",
        Default = 10,
        Min = 5,
        Max = 50,
        Rounding = 0,
        Callback = function(value)
            hitboxConfig.size = value
        end
    })
    
    murderTab:AddToggle("ShowHitbox", {
        Title = "Show Hitbox ESP",
        Description = "Display visual box around expanded hitbox",
        Default = true,
        Callback = function(value)
            hitboxConfig.visible = value
        end
    })
    
    murderTab:AddSlider("HitboxTransparency", {
        Title = "Hitbox Transparency",
        Description = "0 = solid, 1 = invisible",
        Default = 0.5,
        Min = 0.0,
        Max = 1.0,
        Rounding = 2,
        Callback = function(value)
            hitboxConfig.transparency = value
        end
    })
    
    murderTab:AddColorpicker("HitboxColor", {
        Title = "Hitbox Color",
        Description = "Color of the hitbox visualization",
        Default = Color3.fromRGB(255, 0, 80),
        Callback = function(value)
            hitboxConfig.color = value
        end
    })
    
    murderTab:AddParagraph({
        Title = "How it works",
        Content = "Creates an invisible expanded hitbox around players that detects hits. Visual box shows the hitbox area."
    })
end

-- ==================== PLAYER TAB ====================
do
    playerTab:AddSection("Movement")
    
    playerTab:AddSlider("Speed", {
        Title = "Walk Speed",
        Description = "Change your walk speed",
        Default = 16,
        Min = 16,
        Max = 200,
        Rounding = 0,
        Callback = function(value)
            setSpeed(value)
        end
    })
    
    playerTab:AddSlider("Jump", {
        Title = "Jump Power",
        Description = "Change your jump power",
        Default = 50,
        Min = 50,
        Max = 200,
        Rounding = 0,
        Callback = function(value)
            setJump(value)
        end
    })
    
    playerTab:AddSection("Abilities")
    
    playerTab:AddToggle("NoClip", {
        Title = "No Clip",
        Description = "Walk through walls",
        Default = false,
        Callback = function(value)
            if value then
                startNoClip()
            else
                stopNoClip()
            end
        end
    })
end

-- ==================== VISUAL TAB ====================
do
    visualTab:AddSection("ESP Settings")
    
    local ToggleESP = visualTab:AddToggle("PlayerESP", {
        Title = "Player ESP",
        Description = "See players through walls with highlights",
        Default = false
    })
    
    ToggleESP:OnChanged(function(value)
        if value then
            enablePlayerESP()
        else
            disablePlayerESP()
        end
    end)
    
    visualTab:AddSection("ESP Name Settings")
    
    local ToggleName = visualTab:AddToggle("ESPName", {
        Title = "Show Name",
        Description = "Display player names above them",
        Default = true
    })
    
    ToggleName:OnChanged(function(value)
        espConfig.nameEnabled = value
    end)
    
    visualTab:AddSlider("NameSize", {
        Title = "Name Size",
        Description = "Adjust the text size of names",
        Default = 14,
        Min = 10,
        Max = 30,
        Rounding = 0,
        Callback = function(value)
            espConfig.nameSize = value
        end
    })
    
    visualTab:AddSection("ESP Colors")
    
    visualTab:AddColorpicker("InnocentColor", {
        Title = "Innocent Color",
        Description = "Color for innocent players",
        Default = Color3.fromHex("#00ff00"),
        Callback = function(value)
            espConfig.innocentColor = value
        end
    })
    
    visualTab:AddColorpicker("SheriffColor", {
        Title = "Sheriff Color",
        Description = "Color for sheriff player",
        Default = Color3.fromHex("#0026ff"),
        Callback = function(value)
            espConfig.sheriffColor = value
        end
    })
    
    visualTab:AddColorpicker("MurdererColor", {
        Title = "Murderer Color",
        Description = "Color for murderer player",
        Default = Color3.fromHex("#ff0000"),
        Callback = function(value)
            espConfig.murdererColor = value
        end
    })
    
    visualTab:AddParagraph({
        Title = "ESP Info",
        Content = "ESP highlights players with colored outlines. Green = Innocent, Blue = Sheriff, Red = Murderer. Customize colors and name display to your preference."
    })

    visualTab:AddSection("Item ESP")

    visualTab:AddParagraph({
        Title = "Item ESP",
        Content = "Show dropped guns and coins on the map through walls."
    })

    local ToggleGunESP = visualTab:AddToggle("GunESP", {
        Title = "Gun ESP",
        Description = "Highlight dropped guns on the map",
        Default = false
    })

    ToggleGunESP:OnChanged(function(value)
        espConfig.gunEnabled = value
        if value then
            enableGunESP()
        else
            disableGunESP()
        end
    end)

    local ToggleCoinESP = visualTab:AddToggle("CoinESP", {
        Title = "Coin ESP",
        Description = "Highlight coins on the map",
        Default = false
    })

    ToggleCoinESP:OnChanged(function(value)
        espConfig.coinEnabled = value
        if value then
            enableCoinESP()
        else
            disableCoinESP()
        end
    end)
end

-- ==================== AUTO FARM TAB ====================
do
    autoFarmTab:AddSection("Auto Farm")
    
    autoFarmTab:AddToggle("AntiAFK", {
        Title = "Anti-AFK",
        Description = "Prevent being kicked for inactivity",
        Default = false,
        Callback = function(value)
            if value then
                startAntiAFK()
            else
                stopAntiAFK()
            end
        end
    })
    
    autoFarmTab:AddParagraph({
        Title = "Info",
        Content = "Anti-AFK keeps you in the game by simulating activity."
    })
end

-- ==================== CONFIGURAÇÃO FINAL ====================

-- Sistema de reset quando personagem spawna (nova rodada)
-- Limpa entradas de velocidade de jogadores que saíram (evita memory leak)
-- velocityHistory usa HRP como chave — HRPs antigos ficam presos se não limpar
game.Players.PlayerRemoving:Connect(function(player)
    -- Remove todas as entradas cujo HRP pertencia a este jogador
    local char = player.Character
    if char then
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if hrp then
            velocityHistory[hrp] = nil
            accelerationHistory[hrp] = nil
        end
    end
end)

game.Players.LocalPlayer.CharacterAdded:Connect(function(character)
    -- Aguarda o personagem carregar completamente
    task.wait(0.5)

    -- Reseta estado de tiro
    podeAtirar = true
    equipAttempts = 0  -- reseta tentativas de equip (pode ter ficado > 0 se morreu durante equip)

    -- Limpa histórico de velocidade e aceleração (HRPs antigos, nova rodada)
    velocityHistory = {}
    accelerationHistory = {}
    
    -- Aguarda o Humanoid carregar
    local humanoid = character:WaitForChild("Humanoid", 5)
    if humanoid then
        -- Reaplica velocidade e jump power
        if MY_SPEED ~= 16 then
            humanoid.WalkSpeed = MY_SPEED
        end
        if MY_JUMP ~= 50 then
            humanoid.JumpPower = MY_JUMP
        end
        -- Monitora resets do jogo (ex: MM2 reseta WalkSpeed ao puxar faca)
        hookHumanoidStats(humanoid)
    end
    
    -- Recria botão se estiver habilitado
    if sheriffConfig.showButton and not botaoTela then
        task.wait(0.5)
        CriarBotaoTela()
    end

    -- Recacheia parts do noclip se estiver ativo
    if noclipActive then
        cacheNoclipParts()
    end

end)

-- Garante que o estado inicial está correto
podeAtirar = true

-- Hook inicial: se o personagem já existe quando o script carrega
local _initChar = game.Players.LocalPlayer.Character
if _initChar then
    local _initHum = _initChar:FindFirstChild("Humanoid")
    if _initHum then hookHumanoidStats(_initHum) end
end

-- SaveManager e InterfaceManager
GUI.SaveManager:SetFolder("moon")
GUI.SaveManager:SetFolder("moon/mm2")
GUI.InterfaceManager:SetLibrary(GUI)
GUI.InterfaceManager:BuildInterfaceSection(settingsTab)
GUI.SaveManager:IgnoreThemeSettings()
GUI.SaveManager:SetLibrary(GUI)
GUI.SaveManager:BuildConfigSection(settingsTab)
GUI.SaveManager:LoadAutoloadConfig()
