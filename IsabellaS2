local GUI = loadstring(game:HttpGet("https://usemoon.xyz/library"))()

local UDimSize
if game:GetService("UserInputService").TouchEnabled then
    UDimSize = UDim2.fromOffset(490, 290)
else
    UDimSize = UDim2.fromOffset(600, 335)
end

local main = GUI:CreateWindow({
    Title = "MOON running in " .. identifyexecutor(),
    SubTitle = "MM2",
    Icon = "moon",
    TabWidth = 50,
    Size = UDimSize,
    Theme = "supernova",
    MinimizeKey = Enum.KeyCode.M
})

local sheriffTab = main:AddTab({ Title = "Sheriff", Icon = "crosshair" })
local murderTab = main:AddTab({ Title = "Murder", Icon = "skull" })
local playerTab = main:AddTab({ Title = "Player", Icon = "user" })
local visualTab = main:AddTab({ Title = "Visual", Icon = "eye" })
local autoFarmTab = main:AddTab({ Title = "Auto Farm", Icon = "zap" })
local settingsTab = main:AddTab({ Title = "Settings", Icon = "settings" })

-- Sistema de funções e conexões
local functions = {}
local connections = {}

-- Função para criar conexões com delay opcional
function functions.createconnection(name, source, callback, delay)
    if connections[name] then
        connections[name]:Disconnect()
    end

    local locked = false

    local function handler(...)
        if delay then
            if locked then return end
            locked = true
            task.delay(delay, function()
                locked = false
            end)
        end
        callback(...)
    end

    local signal =
        typeof(source) == "string" and game:GetService("RunService")[source]
        or typeof(source) == "RBXScriptSignal" and source
        or (type(source) == "table" and source.Connect and source)

    if not signal then
        return nil
    end

    connections[name] = signal:Connect(handler)
    return connections[name]
end

-- Função para fechar conexões
function functions.closeconnection(name)
    if connections[name] then
        connections[name]:Disconnect()
        connections[name] = nil
        return true
    end
    return false
end


-- Configurações Sheriff
local sheriffConfig = {
    showButton = false,
    PingPrediction = true,
    PingSensitivity = 1.18,
    JumpPrediction = true,
    HorizontalMultiplier = 1.00,
    VerticalMultiplier = 1.00,
    MaxPredictionDistance = 350.00,
    VerticalDistanceScale = 2.00,
    LeadTime = 0.05,
    XMultiplier = 0.00,
    ZMultiplier = 0.00,
    UnequipAfterShot = false
}

-- Configurações Hitbox
local hitboxConfig = {
    enabled = false,
    size = 10,
    visible = true,
    transparency = 0.5,
    color = Color3.fromRGB(255, 0, 80)
}

-- Configurações ESP
local espConfig = {
    enabled = false,
    innocentColor = Color3.fromHex("#00ff00"),    -- Verde
    sheriffColor = Color3.fromHex("#0026ff"),     -- Azul
    murdererColor = Color3.fromHex("#ff0000"),    -- Vermelho
    nameEnabled = true,
    nameSize = 14,
    gunEnabled = false,
    coinEnabled = false
}

-- Variáveis de estado
local pingCache = 0
local lastPingUpdate = 0
local PING_UPDATE_INTERVAL = 0.5

local MY_SPEED = 16
local MY_JUMP = 50
local noclipActive = false

-- Cache ESP
local espConnections = {}
local espRunning = false

-- Variáveis Auto Shot melhoradas
local podeAtirar = true
local delayTiro = 0.3
local delayHolster = 0.0

local autoShotConfig = {
    wallCheck = false
}

local shotStats = {
    totalShots = 0,
    lastShotTime = 0,
    avgDistance = 0
}

-- Velocidade de projétil MM2 (estimada empiricamente)
local BULLET_SPEED = 500 -- studs/segundo

-- Variáveis do botão na tela
local botaoTela = nil
local botaoArrastavel = false
local tamanhoBot = 80
local savedBotaoPos = UDim2.new(0.85, 0, 0.5, 0)

-- ==================== FUNÇÕES UTILITÁRIAS ====================

local function getPing()
    local currentTime = tick()
    if currentTime - lastPingUpdate > PING_UPDATE_INTERVAL then
        pingCache = game.Players.LocalPlayer:GetNetworkPing() * 1000
        lastPingUpdate = currentTime
    end
    return pingCache
end

local velocityHistory = {}
local accelerationHistory = {}

local function DesequiparArmaRapido()
    local char = game.Players.LocalPlayer.Character
    if not char then return end
    
    local arma = char:FindFirstChild("Gun")
    if arma then
        local hum = char:FindFirstChild("Humanoid")
        if hum then
            hum:UnequipTools()
        end
    end
end

-- ── SISTEMA DE VELOCIDADE COM TIMESTAMP ─────────────────────────────
-- Mantém histórico de (velocidade, tempo) para:
-- 1. Calcular aceleração via regressão linear (muito mais estável que derivada entre 2 pontos)
-- 2. Saber quanto tempo passou desde a última replicação (para extrapolar posição)
-- Tamanho do buffer: 6 amostras (~100ms a 60fps)
local VEL_BUFFER_SIZE = 6
local W_TOTAL = 21 -- 1+2+3+4+5+6

local DIRECTION_CHANGE_THRESHOLD = math.cos(math.rad(55))

-- Cada entrada do histórico: { vel=Vector3, t=number }
local function getSmoothedVelocity(hrp)
    local current = hrp.Velocity
    local now     = tick()

    if not velocityHistory[hrp] then
        -- Inicializa buffer com a velocidade atual em tempos fictícios
        velocityHistory[hrp] = {}
        for i = 1, VEL_BUFFER_SIZE do
            velocityHistory[hrp][i] = { vel = current, t = now - (VEL_BUFFER_SIZE - i) * 0.016 }
        end
        accelerationHistory[hrp] = Vector3.new(0, 0, 0)
        return current, false
    end

    local h = velocityHistory[hrp]

    -- Detecta mudança brusca de direção (zigzag) comparando atual com última amostra
    local dirChanged = false
    local lastVel    = h[VEL_BUFFER_SIZE].vel
    local curXZ      = Vector2.new(current.X, current.Z)
    local lastXZ     = Vector2.new(lastVel.X, lastVel.Z)
    local curMag     = curXZ.Magnitude
    local lastMag    = lastXZ.Magnitude

    if curMag > 2 and lastMag > 2 then
        local dot = (curXZ / curMag):Dot(lastXZ / lastMag)
        if dot < DIRECTION_CHANGE_THRESHOLD then
            -- Reseta buffer inteiro com velocidade atual
            for i = 1, VEL_BUFFER_SIZE do
                h[i] = { vel = current, t = now - (VEL_BUFFER_SIZE - i) * 0.016 }
            end
            accelerationHistory[hrp] = Vector3.new(0, 0, 0)
            return current, true
        end
    end

    -- Desloca buffer: remove [1] (mais velho), adiciona novo no [VEL_BUFFER_SIZE]
    for i = 1, VEL_BUFFER_SIZE - 1 do
        h[i] = h[i + 1]
    end
    h[VEL_BUFFER_SIZE] = { vel = current, t = now }

    -- ── Aceleração via regressão linear no tempo ──────────────────────
    -- Em vez de vel[n] - vel[n-1] (ruidoso), faz least-squares sobre todas as amostras.
    -- Resultado: tendência real de variação de velocidade, muito menos sensível a spikes.
    local sumT, sumVx, sumVz = 0, 0, 0
    local sumT2, sumTVx, sumTVz = 0, 0, 0
    local t0 = h[1].t  -- normaliza tempo relativo à amostra mais antiga
    for i = 1, VEL_BUFFER_SIZE do
        local dt  = h[i].t - t0
        local vx  = h[i].vel.X
        local vz  = h[i].vel.Z
        sumT   = sumT   + dt
        sumVx  = sumVx  + vx
        sumVz  = sumVz  + vz
        sumT2  = sumT2  + dt * dt
        sumTVx = sumTVx + dt * vx
        sumTVz = sumTVz + dt * vz
    end
    local n    = VEL_BUFFER_SIZE
    local denom = n * sumT2 - sumT * sumT
    local accelX, accelZ = 0, 0
    if math.abs(denom) > 1e-6 then
        accelX = (n * sumTVx - sumT * sumVx) / denom
        accelZ = (n * sumTVz - sumT * sumVz) / denom
    end
    accelerationHistory[hrp] = Vector3.new(accelX, 0, accelZ)

    -- Velocidade suavizada: média ponderada 1-2-3-4-5-6 (mais recente = mais peso)
    local sv = Vector3.new(0, 0, 0)
    for i = 1, VEL_BUFFER_SIZE do
        sv = sv + h[i].vel * i
    end
    return sv / W_TOTAL, false
end

local function getAcceleration(hrp)
    return accelerationHistory[hrp] or Vector3.new(0, 0, 0)
end

-- Retorna o timestamp da amostra mais recente do buffer (para extrapolação)
local function getLastReplicationTime(hrp)
    local h = velocityHistory[hrp]
    if not h then return tick() end
    return h[VEL_BUFFER_SIZE].t
end

-- alvoHRP: HumanoidRootPart (para velocidade/física)
-- alvoAim: Head ou HRP (posição de onde apontar)
local function CalcularPredicaoRapida(alvoHRP, alvoAim, minhaPos)
    if not alvoHRP or not alvoHRP.Parent then return nil end
    if not alvoAim or not alvoAim.Parent then return nil end

    local alvoVelRaw                = alvoHRP.Velocity
    local alvoVelSmooth, dirChanged = getSmoothedVelocity(alvoHRP)
    local alvoAccel                 = getAcceleration(alvoHRP)

    -- Velocidade unica e consistente para solver + predicao final
    local vel = dirChanged and alvoVelRaw or alvoVelSmooth

    -- EXTRPOLACAO: usa HRP (nao Head) para extrapolar, depois reconstroi Head
    -- Head tem offset de animacao; extrapolar Head com velocidade do HRP cria desvio
    local lastRepTime    = getLastReplicationTime(alvoHRP)
    local repLag         = math.min(tick() - lastRepTime, 0.05)
    local hrpExtrapolado = alvoHRP.Position + alvoVelRaw * repLag
    local headOffset     = alvoAim.Position - alvoHRP.Position
    local alvoPos        = hrpExtrapolado + headOffset

    local dist = (alvoPos - minhaPos).Magnitude

    -- PING
    local pingTime = 0
    if sheriffConfig.PingPrediction then
        local ping = getPing()
        pingTime = ping * 0.001 * sheriffConfig.PingSensitivity
        if    ping > 150 then pingTime = pingTime * 1.35
        elseif ping > 100 then pingTime = pingTime * 1.2 end
    end

    -- SOLVER ITERATIVO: w_conv guardado para reusar na posicao final
    -- garante que o peso de aceleracao e identico entre solver e posicao final
    local CONV_STUDS = 0.08
    local horizDist  = Vector2.new(alvoPos.X - minhaPos.X, alvoPos.Z - minhaPos.Z).Magnitude
    local t          = horizDist / BULLET_SPEED
    local w_conv     = 0.50

    for i = 0, 7 do
        local w       = math.max(0.25, 0.50 - i * 0.03)
        local futureX = alvoPos.X + vel.X * t + w * alvoAccel.X * t * t
        local futureZ = alvoPos.Z + vel.Z * t + w * alvoAccel.Z * t * t
        local t_new   = Vector2.new(futureX - minhaPos.X, futureZ - minhaPos.Z).Magnitude / BULLET_SPEED
        if math.abs(t_new - t) * BULLET_SPEED < CONV_STUDS then
            w_conv = w
            t = t_new
            break
        end
        w_conv = w
        t = t_new
    end

    local totalTime = t + pingTime + sheriffConfig.LeadTime

    -- POSICAO FINAL XZ: usa w_conv da iteracao que convergiu (consistente com solver)
    local finalX = alvoPos.X + vel.X * totalTime + w_conv * alvoAccel.X * totalTime * totalTime
    local finalZ = alvoPos.Z + vel.Z * totalTime + w_conv * alvoAccel.Z * totalTime * totalTime

    -- Anti-shake: alvo quase parado com ruido de aceleracao
    if alvoVelRaw.Magnitude < 3 and alvoAccel.Magnitude > 2 then
        finalX = alvoPos.X + vel.X * totalTime * 0.4
        finalZ = alvoPos.Z + vel.Z * totalTime * 0.4
    end

    -- Fine-tune do usuario aplicado no delta, nao na posicao absoluta
    local deltaX = (finalX - alvoPos.X) * sheriffConfig.HorizontalMultiplier + (sheriffConfig.XMultiplier * 10)
    local deltaZ = (finalZ - alvoPos.Z) * sheriffConfig.HorizontalMultiplier + (sheriffConfig.ZMultiplier * 10)

    -- VERTICAL
    local deltaY  = 0
    local velY    = vel.Y
    local gravity = 196.2

    if sheriffConfig.JumpPrediction then
        local hum        = alvoHRP.Parent and alvoHRP.Parent:FindFirstChild("Humanoid")
        local state      = hum and hum:GetState()
        local isAirborne = state == Enum.HumanoidStateType.Freefall
                        or state == Enum.HumanoidStateType.Jumping

        if isAirborne then
            local rayParams = RaycastParams.new()
            rayParams.FilterType = Enum.RaycastFilterType.Blacklist
            rayParams.FilterDescendantsInstances = { alvoHRP.Parent }
            local rayResult = workspace:Raycast(alvoHRP.Position, Vector3.new(0, -50, 0), rayParams)
            local groundDist = rayResult and (alvoHRP.Position.Y - rayResult.Position.Y) or 999

            -- Altura da Head acima do chao quando pousado
            -- = offset atual Head-HRP + altura do HRP acima do chao (~3 studs)
            local headAboveGround = headOffset.Y + 3

            local tPouso = 999
            if velY < 0 then
                local a_eq = 0.5 * gravity
                local b_eq = -velY
                local c_eq = -groundDist
                local disc  = b_eq * b_eq - 4 * a_eq * c_eq
                if disc >= 0 then
                    local r1 = (-b_eq + math.sqrt(disc)) / (2 * a_eq)
                    local r2 = (-b_eq - math.sqrt(disc)) / (2 * a_eq)
                    if r1 > 0 and r2 > 0 then tPouso = math.min(r1, r2)
                    elseif r1 > 0 then tPouso = r1
                    elseif r2 > 0 then tPouso = r2 end
                end
            end

            if tPouso < totalTime then
                -- Pousa antes: mira na Head na posicao de pouso
                -- Y do chao + headAboveGround - Y atual da Head
                -- Se raycast falhou (groundDist=999), nao usar posicao de pouso
                -- pois groundY seria absurdamente negativo
                if rayResult then
                    local groundY = rayResult.Position.Y
                    deltaY = (groundY + headAboveGround) - alvoPos.Y
                else
                    -- Sem chao detectado: usa fisica normal (nao pousa)
                    deltaY = (velY * totalTime) - (0.5 * gravity * totalTime * totalTime)
                end
            else
                deltaY = (velY * totalTime) - (0.5 * gravity * totalTime * totalTime)
            end

            deltaY = deltaY * sheriffConfig.VerticalMultiplier
        end
    end

    -- Bullet drop separado, nao afetado por VerticalMultiplier
    if dist > 80 then
        deltaY = deltaY - (dist - 80) * 0.008 * sheriffConfig.VerticalDistanceScale
    end

    return Vector3.new(alvoPos.X + deltaX, alvoPos.Y + deltaY, alvoPos.Z + deltaZ)
end


-- ==================== FUNÇÕES AVANÇADAS AUTO SHOT ====================

-- (ballistic solver unificado dentro de CalcularPredicaoRapida)

local function hasLineOfSight(fromPos, toPos)
    if not autoShotConfig.wallCheck then return true end
    
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    rayParams.FilterDescendantsInstances = {game.Players.LocalPlayer.Character}
    
    local result = workspace:Raycast(fromPos, (toPos - fromPos), rayParams)
    
    if result then
        -- Verifica se acertou um jogador
        local hitModel = result.Instance:FindFirstAncestorOfClass("Model")
        if hitModel and game.Players:GetPlayerFromCharacter(hitModel) then
            return true
        end
        return false
    end
    
    return true
end

local function getScoreForTarget(hrp, myPos)
    -- Sistema de pontuação OTIMIZADO para escolher melhor alvo
    local score = 0
    local dist = (hrp.Position - myPos).Magnitude
    
    -- Pontos por proximidade (mais perto = MUITO melhor)
    score = score + (1500 - dist)
    
    -- Pontos se tiver linha de visão
    if hasLineOfSight(myPos, hrp.Position) then
        score = score + 500
    end
    
    -- Penalidade MAIOR por velocidade alta (alvos rápidos são mais difíceis)
    local vel = hrp.Velocity.Magnitude
    score = score - (vel * 5)
    
    -- Bônus se o alvo estiver no chão (mais fácil acertar)
    local hum = hrp.Parent and hrp.Parent:FindFirstChild("Humanoid")
    if hum then
        local state = hum:GetState()
        if state ~= Enum.HumanoidStateType.Freefall and state ~= Enum.HumanoidStateType.Flying then
            score = score + 200
        end
    end
    
    return score
end

local function AcharMelhorAlvo()
    -- SMART TARGETING sempre ativo
    local char = game.Players.LocalPlayer.Character
    if not char then return nil end
    
    local myPos = char:FindFirstChild("HumanoidRootPart")
    if not myPos then return nil end
    myPos = myPos.Position
    
    local bestTarget = nil
    local bestScore = -math.huge
    
    local players = game.Players:GetPlayers()
    for i = 1, #players do
        local v = players[i]
        if v ~= game.Players.LocalPlayer and v.Parent then
            local char = v.Character
            if char and char.Parent then
                local hrp = char:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local backpack = v:FindFirstChild("Backpack")
                    if (char:FindFirstChild("Knife")) or (backpack and backpack:FindFirstChild("Knife")) then
                        local score = getScoreForTarget(hrp, myPos)
                        
                        if score > bestScore then
                            bestScore = score
                            bestTarget = hrp
                        end
                    end
                end
            end
        end
    end
    
    return bestTarget
end

-- ==================== AUTO SHOT MELHORADO ====================

local equipAttempts = 0  -- previne loop infinito de equip

local function Atirar()
    if not podeAtirar then return end

    local char = game.Players.LocalPlayer.Character
    if not char or not char.Parent then return end

    local hum = char:FindFirstChild("Humanoid")
    if not hum or hum.Health <= 0 then return end

    local head = char:FindFirstChild("Head")
    if not head then return end

    -- ── 1. ACHA O ALVO ──────────────────────────────────────────────
    local alvo = AcharMelhorAlvo()
    if not alvo or not alvo.Parent then return end

    local humAlvo = alvo.Parent:FindFirstChild("Humanoid")
    if not humAlvo or humAlvo.Health <= 0 then return end

    local headAlvo   = alvo.Parent:FindFirstChild("Head")
    local alvoAimPos = headAlvo or alvo

    -- dist calculada da Head do alvo (igual ao alvo de mira real)
    -- antes usava HRP — causava rejeitar alvo válido por +3 studs
    local dist = (alvoAimPos.Position - head.Position).Magnitude
    if dist > sheriffConfig.MaxPredictionDistance then return end

    -- ── 2. WALL CHECK ────────────────────────────────────────────────
    if autoShotConfig.wallCheck and not hasLineOfSight(head.Position, alvo.Position) then
        return
    end

    -- ── 3. EQUIPA A ARMA (máx 3 tentativas — evita loop infinito) ───
    local arma = char:FindFirstChild("Gun")
    if not arma then
        if equipAttempts >= 3 then
            equipAttempts = 0
            return
        end
        local gunInBackpack = game.Players.LocalPlayer.Backpack:FindFirstChild("Gun")
        if not gunInBackpack then equipAttempts = 0; return end

        equipAttempts = equipAttempts + 1
        task.spawn(function()
            hum:EquipTool(gunInBackpack)
            task.wait(0.05)
            if podeAtirar then Atirar() end
        end)
        return
    end
    equipAttempts = 0

    local evento = arma:FindFirstChild("Shoot")
    if not evento then return end

    -- ── 4. EXECUTA O TIRO ────────────────────────────────────────────
    local function executarTiro()
        if not podeAtirar then return end
        if not alvo or not alvo.Parent then return end
        if not humAlvo or humAlvo.Health <= 0 then return end
        if not alvoAimPos or not alvoAimPos.Parent then return end

        local posPredicao = CalcularPredicaoRapida(alvo, alvoAimPos, head.Position)
        if not posPredicao then return end

        if (posPredicao - alvoAimPos.Position).Magnitude > 40 then
            posPredicao = alvoAimPos.Position
        end

        evento:FireServer(CFrame.new(head.Position, posPredicao), CFrame.new(posPredicao))

        podeAtirar = false

        -- dist recalculada no momento real do tiro (alvo pode ter se movido durante apex)
        local distAtual = (alvoAimPos.Position - head.Position).Magnitude
        local adaptiveDelay
        if distAtual < 50 then
            adaptiveDelay = delayTiro * 0.7
        elseif distAtual < 120 then
            adaptiveDelay = delayTiro
        elseif distAtual < 220 then
            adaptiveDelay = delayTiro * 1.3
        else
            adaptiveDelay = delayTiro * 1.6
        end
        task.delay(adaptiveDelay, function() podeAtirar = true end)

        if sheriffConfig.UnequipAfterShot then
            task.delay(delayHolster > 0 and delayHolster or 0.05, DesequiparArmaRapido)
        end
    end

    -- ── 5. APEX DETECTION ────────────────────────────────────────────
    local stateAlvo = humAlvo:GetState()
    local velYAlvo  = alvo.Velocity.Y
    local noApex    = (stateAlvo == Enum.HumanoidStateType.Freefall
                    or stateAlvo == Enum.HumanoidStateType.Jumping)
                   and math.abs(velYAlvo) < 8

    if noApex then
        podeAtirar = false
        local apexConn
        -- Timeout garante que podeAtirar SEMPRE volta para true
        -- Antes: se apexConn falhasse, podeAtirar ficava false para sempre
        local timeoutHandle = task.delay(0.12, function()
            if apexConn then apexConn:Disconnect(); apexConn = nil end
            podeAtirar = true
            executarTiro()
        end)
        apexConn = game:GetService("RunService").Heartbeat:Connect(function()
            if not apexConn then return end
            -- Alvo sumiu durante espera: libera sem atirar
            if not alvo or not alvo.Parent then
                apexConn:Disconnect(); apexConn = nil
                task.cancel(timeoutHandle)
                podeAtirar = true
                return
            end
            if alvo.Velocity.Y < -5 then
                apexConn:Disconnect(); apexConn = nil
                task.cancel(timeoutHandle)
                podeAtirar = true
                executarTiro()
            end
        end)
    else
        executarTiro()
    end
end

-- ==================== BOTÃO NA TELA AUTO SHOT ====================

local function CriarBotaoTela()
    if botaoTela then return end

    local sg = Instance.new("ScreenGui")
    sg.Name = "SilentAimBtnUltra"
    sg.ResetOnSpawn = false
    sg.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    sg.IgnoreGuiInset = true

    local container = Instance.new("Frame")
    container.Name = "MainContainer"
    container.Size = UDim2.new(0, tamanhoBot, 0, tamanhoBot)
    container.Position = savedBotaoPos
    container.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    container.BackgroundTransparency = 0.3
    container.BorderSizePixel = 0
    container.Parent = sg

    local containerCorner = Instance.new("UICorner")
    containerCorner.CornerRadius = UDim.new(0, 12)
    containerCorner.Parent = container

    local outerCircle = Instance.new("Frame")
    outerCircle.Name = "OuterCircle"
    outerCircle.Size = UDim2.new(0, tamanhoBot * 0.6, 0, tamanhoBot * 0.6)
    outerCircle.Position = UDim2.new(0.5, 0, 0.5, 0)
    outerCircle.AnchorPoint = Vector2.new(0.5, 0.5)
    outerCircle.BackgroundTransparency = 1
    outerCircle.BorderSizePixel = 0
    outerCircle.Parent = container

    local outerStroke = Instance.new("UIStroke")
    outerStroke.Color = Color3.fromRGB(255, 255, 255)
    outerStroke.Thickness = 3
    outerStroke.Parent = outerCircle

    Instance.new("UICorner", outerCircle).CornerRadius = UDim.new(1, 0)

    local centerDot = Instance.new("Frame")
    centerDot.Name = "CenterDot"
    centerDot.Size = UDim2.new(0, tamanhoBot * 0.15, 0, tamanhoBot * 0.15)
    centerDot.Position = UDim2.new(0.5, 0, 0.5, 0)
    centerDot.AnchorPoint = Vector2.new(0.5, 0.5)
    centerDot.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    centerDot.BorderSizePixel = 0
    centerDot.Parent = container
    Instance.new("UICorner", centerDot).CornerRadius = UDim.new(1, 0)

    local function createAimLine(name, rotation, xOffset, yOffset)
        local line = Instance.new("Frame")
        line.Name = name
        line.Size = UDim2.new(0, 3, 0, tamanhoBot * 0.12)
        line.Position = UDim2.new(0.5, xOffset, 0.5, yOffset)
        line.AnchorPoint = Vector2.new(0.5, 0.5)
        line.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        line.BorderSizePixel = 0
        line.Rotation = rotation
        line.Parent = container
        Instance.new("UICorner", line).CornerRadius = UDim.new(1, 0)
    end

    createAimLine("TopLine",    0,    0,              -(tamanhoBot * 0.25))
    createAimLine("BottomLine", 0,    0,               (tamanhoBot * 0.25))
    createAimLine("LeftLine",   90, -(tamanhoBot * 0.25), 0)
    createAimLine("RightLine",  90,  (tamanhoBot * 0.25), 0)

    local btn = Instance.new("TextButton")
    btn.Name = "ClickButton"
    btn.Size = UDim2.new(1, 0, 1, 0)
    btn.BackgroundTransparency = 1
    btn.Text = ""
    btn.AutoButtonColor = false
    btn.Parent = container

    -- Feedback visual ao pressionar
    local function setPressed(on)
        container.BackgroundTransparency = on and 0.05 or 0.3
        outerStroke.Color = on and Color3.fromRGB(255, 80, 80) or Color3.fromRGB(255, 255, 255)
    end

    -- HOLD: pressionar inicia o auto shot, soltar para
    local lastClickTime = 0
    btn.InputBegan:Connect(function(input)
        local isTouch = input.UserInputType == Enum.UserInputType.Touch
        local isMouse = input.UserInputType == Enum.UserInputType.MouseButton1

        if isTouch or isMouse then
            if botaoArrastavel then
                -- Modo arraste: não dispara, só move
                local startPos = input.Position
                local startFrame = container.Position
                local moved = false

                local moveConn, endConn
                moveConn = game:GetService("UserInputService").InputChanged:Connect(function(inp)
                    if inp == input or inp.UserInputType == Enum.UserInputType.MouseMovement then
                        local delta = inp.Position - startPos
                        if delta.Magnitude > 5 then moved = true end
                        container.Position = UDim2.new(
                            startFrame.X.Scale,
                            startFrame.X.Offset + delta.X,
                            startFrame.Y.Scale,
                            startFrame.Y.Offset + delta.Y
                        )
                    end
                end)

                endConn = input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        savedBotaoPos = container.Position
                        moveConn:Disconnect()
                        endConn:Disconnect()
                    end
                end)
            else
                -- Modo disparo: tiro único ao pressionar
                local success, errorMsg = pcall(function()
                    setPressed(true)
                    Atirar()
                    task.delay(0.1, function() setPressed(false) end)
                end)
                
                if not success then
                    setPressed(false)
                    warn("Button Shot Error:", errorMsg)
                end
            end
        end
    end)

    sg.Parent = game:GetService("CoreGui")
    botaoTela = sg
end

local function RemoverBotaoTela()
    if botaoTela then
        botaoTela:Destroy()
        botaoTela = nil
    end
end

local function AtualizarTamanhoBotao()
    if not botaoTela then return end
    local container = botaoTela:FindFirstChild("MainContainer")
    if not container then return end

    container.Size = UDim2.new(0, tamanhoBot, 0, tamanhoBot)

    local outerCircle = container:FindFirstChild("OuterCircle")
    if outerCircle then
        outerCircle.Size = UDim2.new(0, tamanhoBot * 0.6, 0, tamanhoBot * 0.6)
    end

    local centerDot = container:FindFirstChild("CenterDot")
    if centerDot then
        centerDot.Size = UDim2.new(0, tamanhoBot * 0.15, 0, tamanhoBot * 0.15)
    end

    local lines = {
        { name = "TopLine",    xOff = 0,                  yOff = -(tamanhoBot * 0.25) },
        { name = "BottomLine", xOff = 0,                  yOff =  (tamanhoBot * 0.25) },
        { name = "LeftLine",   xOff = -(tamanhoBot * 0.25), yOff = 0                  },
        { name = "RightLine",  xOff =  (tamanhoBot * 0.25), yOff = 0                  },
    }
    for _, d in ipairs(lines) do
        local line = container:FindFirstChild(d.name)
        if line then
            line.Size = UDim2.new(0, 3, 0, tamanhoBot * 0.12)
            line.Position = UDim2.new(0.5, d.xOff, 0.5, d.yOff)
        end
    end
end

-- ==================== HITBOX SYSTEM (NOVO - DO ZERO) ====================

local hitboxParts = {}
local hitboxConnections = {}
local originalSizes = {}

local function createHitboxForPlayer(player)
    if player == game.Players.LocalPlayer then return end
    if not player.Character then return end
    
    local character = player.Character
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    local playerName = player.Name
    
    -- Salva tamanho original do HRP
    if not originalSizes[playerName] then
        originalSizes[playerName] = hrp.Size
    end
    
    -- MODIFICA O HRP DIRETAMENTE (isso que faz funcionar!)
    hrp.Size = Vector3.new(hitboxConfig.size, hitboxConfig.size, hitboxConfig.size)
    hrp.Transparency = 0.9  -- Quase invisível mas ainda renderiza
    hrp.Material = Enum.Material.ForceField
    hrp.CanCollide = false
    
    -- Cria visualização (BoxHandleAdornment)
    -- Remove visual antigo se existir
    local oldVisual = hrp:FindFirstChild("HitboxVisual")
    if oldVisual then oldVisual:Destroy() end
    
    if hitboxConfig.visible then
        local box = Instance.new("BoxHandleAdornment")
        box.Name = "HitboxVisual"
        box.Adornee = hrp
        box.Size = hrp.Size
        box.Color3 = hitboxConfig.color
        box.Transparency = hitboxConfig.transparency
        box.AlwaysOnTop = true
        box.ZIndex = 1
        box.Parent = hrp
    end
    
    hitboxParts[playerName] = hrp
end

local function updateAllHitboxes()
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer and player.Character then
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                -- Atualiza tamanho do HRP
                local newSize = Vector3.new(hitboxConfig.size, hitboxConfig.size, hitboxConfig.size)
                if hrp.Size ~= newSize then
                    hrp.Size = newSize
                    hrp.Transparency = 0.9
                    hrp.Material = Enum.Material.ForceField
                    hrp.CanCollide = false
                end
                
                -- Atualiza visual
                local visual = hrp:FindFirstChild("HitboxVisual")
                if hitboxConfig.visible then
                    if not visual then
                        visual = Instance.new("BoxHandleAdornment")
                        visual.Name = "HitboxVisual"
                        visual.Adornee = hrp
                        visual.AlwaysOnTop = true
                        visual.ZIndex = 1
                        visual.Parent = hrp
                    end
                    visual.Size = hrp.Size
                    visual.Color3 = hitboxConfig.color
                    visual.Transparency = hitboxConfig.transparency
                else
                    if visual then
                        visual:Destroy()
                    end
                end
            else
                -- Recria se não existe
                createHitboxForPlayer(player)
            end
        end
    end
end

local function startHitbox()
    -- Cria hitbox para todos os jogadores atuais
    for _, player in ipairs(game.Players:GetPlayers()) do
        createHitboxForPlayer(player)
    end
    
    -- Monitora novos jogadores
    hitboxConnections.playerAdded = game.Players.PlayerAdded:Connect(function(player)
        player.CharacterAdded:Connect(function()
            task.wait(0.5)
            if hitboxConfig.enabled then
                createHitboxForPlayer(player)
            end
        end)
    end)
    
    -- Monitora respawn de jogadores existentes
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            hitboxConnections[player.Name] = player.CharacterAdded:Connect(function()
                task.wait(0.5)
                if hitboxConfig.enabled then
                    createHitboxForPlayer(player)
                end
            end)
        end
    end
    
    -- Loop de manutenção throttled: 10x/s em vez de 60x/s
    -- Rodar updateAllHitboxes todo frame causava travamentos (GetPlayers + iteração a 60fps)
    local lastHitboxUpdate = 0
    hitboxConnections.heartbeat = game:GetService("RunService").Heartbeat:Connect(function()
        if not hitboxConfig.enabled then return end
        local now = tick()
        if now - lastHitboxUpdate < 0.1 then return end
        lastHitboxUpdate = now
        updateAllHitboxes()
    end)
    
    -- Cleanup quando jogador sai
    hitboxConnections.playerRemoving = game.Players.PlayerRemoving:Connect(function(player)
        local playerName = player.Name
        
        -- Restaura tamanho original
        if player.Character then
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            if hrp and originalSizes[playerName] then
                hrp.Size = originalSizes[playerName]
                hrp.Transparency = 1
                hrp.CanCollide = false
            end
        end
        
        originalSizes[playerName] = nil
        hitboxParts[playerName] = nil
        
        if hitboxConnections[playerName] then
            hitboxConnections[playerName]:Disconnect()
            hitboxConnections[playerName] = nil
        end
    end)
end

local function stopHitbox()
    -- Desconecta todos os eventos (incluindo nested connections)
    for name, conn in pairs(hitboxConnections) do
        if conn then
            pcall(function() 
                if typeof(conn) == "RBXScriptConnection" then
                    conn:Disconnect()
                end
            end)
        end
    end
    hitboxConnections = {}
    
    -- Restaura todos os HRPs ao tamanho original
    for playerName, hrp in pairs(hitboxParts) do
        if hrp and hrp.Parent then
            pcall(function()
                -- Remove visual
                local visual = hrp:FindFirstChild("HitboxVisual")
                if visual then visual:Destroy() end
                
                -- Restaura tamanho
                if originalSizes[playerName] then
                    hrp.Size = originalSizes[playerName]
                else
                    hrp.Size = Vector3.new(2, 2, 1) -- Tamanho padrão
                end
                hrp.Transparency = 1
                hrp.CanCollide = false
            end)
        end
    end
    
    hitboxParts = {}
    originalSizes = {}
end

-- ==================== ESP SYSTEM (PLAYER) ====================

local function CreateESP(targetPlayer)
    if targetPlayer == game.Players.LocalPlayer then return end
    
    local function ApplyESP(character)
        if not character then return end
        
        -- Esperar o corpo carregar
        local root = character:WaitForChild("HumanoidRootPart", 10)
        if not root then return end
        
        -- 1. Highlight (contorno colorido)
        local highlight = character:FindFirstChild("MoonHighlight") or Instance.new("Highlight")
        highlight.Name = "MoonHighlight"
        highlight.Parent = character
        highlight.Adornee = character
        highlight.FillTransparency = 1
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        
        -- 2. Tag com nome do player
        local tag = root:FindFirstChild("MoonTag") or Instance.new("BillboardGui")
        tag.Name = "MoonTag"
        tag.Size = UDim2.new(0, 200, 0, 50)
        tag.AlwaysOnTop = true
        tag.StudsOffset = Vector3.new(0, 3.5, 0)
        tag.Parent = root
        
        local label = tag:FindFirstChild("Label") or Instance.new("TextLabel")
        label.Name = "Label"
        label.Parent = tag
        label.BackgroundTransparency = 1
        label.Size = UDim2.new(1, 0, 1, 0)
        label.Text = targetPlayer.Name
        label.Font = Enum.Font.GothamBold
        label.TextSize = espConfig.nameSize
        label.TextStrokeTransparency = 0
        label.TextScaled = false
        
        -- Loop de atualização de cores e visibilidade (throttled: ~10x/s, não 60x/s)
        local updateConnection
        local lastESPUpdate = 0
        updateConnection = game:GetService("RunService").Heartbeat:Connect(function()
            local now = tick()
            if now - lastESPUpdate < 0.1 then return end
            lastESPUpdate = now

            if not character or not character.Parent then
                if updateConnection then
                    updateConnection:Disconnect()
                end
                return
            end
            
            if not espConfig.enabled then return end
            
            local color = espConfig.innocentColor
            
            -- Checar inventário para determinar role
            local backpack = targetPlayer:FindFirstChild("Backpack")
            local hasKnife = (backpack and backpack:FindFirstChild("Knife")) or character:FindFirstChild("Knife")
            local hasGun = (backpack and backpack:FindFirstChild("Gun")) or character:FindFirstChild("Gun")
            
            if hasKnife then
                color = espConfig.murdererColor
            elseif hasGun then
                color = espConfig.sheriffColor
            end
            
            -- Aplicar cores
            highlight.OutlineColor = color
            label.TextColor3 = color
            label.Text = targetPlayer.Name
            label.TextSize = espConfig.nameSize
            
            -- Controlar visibilidade do nome
            tag.Enabled = espConfig.nameEnabled and espConfig.enabled
        end)
        
        -- Salvar conexão para cleanup
        table.insert(espConnections, {
            player = targetPlayer,
            connection = updateConnection,
            highlight = highlight,
            tag = tag
        })
    end
    
    -- Aplicar ESP ao personagem atual
    if targetPlayer.Character then
        ApplyESP(targetPlayer.Character)
    end
    
    -- Conectar evento de personagem adicionado
    local charConnection = targetPlayer.CharacterAdded:Connect(ApplyESP)
    table.insert(espConnections, {
        player = targetPlayer,
        connection = charConnection,
        charConnection = true
    })
end

local function enablePlayerESP()
    if espRunning then return end
    espRunning = true
    espConfig.enabled = true
    
    -- Limpar conexões antigas
    for _, conn in pairs(espConnections) do
        if conn.connection and conn.connection.Connected then
            conn.connection:Disconnect()
        end
        if conn.highlight then
            conn.highlight:Destroy()
        end
        if conn.tag then
            conn.tag:Destroy()
        end
    end
    espConnections = {}
    
    -- Criar ESP para todos os players
    for _, plr in pairs(game.Players:GetPlayers()) do
        CreateESP(plr)
    end
    
    -- Conectar novo jogador
    local playerAddedConnection = game.Players.PlayerAdded:Connect(CreateESP)
    table.insert(espConnections, {connection = playerAddedConnection})
    
    -- Conectar jogador removido
    local playerRemovingConnection = game.Players.PlayerRemoving:Connect(function(plr)
        -- Limpar ESP do jogador removido
        for i = #espConnections, 1, -1 do
            local conn = espConnections[i]
            if conn.player == plr then
                if conn.connection and conn.connection.Connected then
                    conn.connection:Disconnect()
                end
                if conn.highlight then
                    conn.highlight:Destroy()
                end
                if conn.tag then
                    conn.tag:Destroy()
                end
                table.remove(espConnections, i)
            end
        end
    end)
    table.insert(espConnections, {connection = playerRemovingConnection})
end

local function disablePlayerESP()
    espRunning = false
    espConfig.enabled = false
    
    -- Desconectar todas as conexões
    for _, conn in pairs(espConnections) do
        if conn.connection and conn.connection.Connected then
            conn.connection:Disconnect()
        end
        if conn.highlight then
            conn.highlight:Destroy()
        end
        if conn.tag then
            conn.tag:Destroy()
        end
    end
    espConnections = {}
    
    -- Limpar ESP manualmente de todos os jogadores
    for _, plr in pairs(game.Players:GetPlayers()) do
        if plr.Character then
            local highlight = plr.Character:FindFirstChild("MoonHighlight")
            if highlight then
                highlight:Destroy()
            end
            
            local root = plr.Character:FindFirstChild("HumanoidRootPart")
            if root then
                local tag = root:FindFirstChild("MoonTag")
                if tag then
                    tag:Destroy()
                end
            end
        end
    end
end

-- ==================== ESP GUN (portado do Sun_Main) ====================

local gunESPConnection = nil

local function applyGunESP(v)
    if v.Name ~= "GunDrop" then return end
    if not v:FindFirstChild("GunESP_Highlight") then
        local highlight = Instance.new("Highlight")
        highlight.Name = "GunESP_Highlight"
        highlight.Parent = v
        highlight.FillColor = Color3.fromRGB(255, 255, 0)
        highlight.OutlineColor = Color3.new(1, 1, 1)
        highlight.FillTransparency = 0.5
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    end
    if not v:FindFirstChild("GunESP_Name") then
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "GunESP_Name"
        billboard.Parent = v
        billboard.AlwaysOnTop = true
        billboard.Size = UDim2.new(0, 100, 0, 50)
        billboard.StudsOffset = Vector3.new(0, 2, 0)
        local label = Instance.new("TextLabel")
        label.Parent = billboard
        label.BackgroundTransparency = 1
        label.Size = UDim2.new(1, 0, 1, 0)
        label.Text = "GUN"
        label.TextColor3 = Color3.fromRGB(255, 255, 0)
        label.TextStrokeTransparency = 0
        label.TextSize = 14
        label.Font = Enum.Font.SourceSansBold
    end
end

local function enableGunESP()
    if gunESPConnection then return end
    -- Aplica nas armas já existentes
    for _, v in pairs(workspace:GetDescendants()) do
        applyGunESP(v)
    end
    -- Detecta novas armas via evento (sem loop pesado)
    gunESPConnection = functions.createconnection("GunESP_Loop", workspace.DescendantAdded, function(v)
        if espConfig.gunEnabled then
            applyGunESP(v)
        end
    end)
end

local function disableGunESP()
    espConfig.gunEnabled = false
    functions.closeconnection("GunESP_Loop")
    gunESPConnection = nil
    for _, v in pairs(workspace:GetDescendants()) do
        if v:FindFirstChild("GunESP_Highlight") then v.GunESP_Highlight:Destroy() end
        if v:FindFirstChild("GunESP_Name") then v.GunESP_Name:Destroy() end
    end
end

-- ==================== ESP COIN (portado do Sun_Main) ====================

local coinESPConnection = nil

local function aplicarCoinESP(objeto)
    if objeto:FindFirstChild("Coin_XRAY") then return end
    local adorn = Instance.new("BoxHandleAdornment")
    adorn.Name = "Coin_XRAY"
    adorn.AlwaysOnTop = true
    adorn.Adornee = objeto
    adorn.ZIndex = 5
    adorn.Size = objeto.Size
    adorn.Color3 = Color3.fromRGB(255, 215, 0)
    adorn.Transparency = 0.6
    adorn.Parent = objeto
    objeto.AncestryChanged:Connect(function(_, parent)
        if not parent then adorn:Destroy() end
    end)
end

local function enableCoinESP()
    if coinESPConnection then return end
    -- Aplica nas moedas já existentes
    for _, v in pairs(workspace:GetDescendants()) do
        if v.Name == "Coin_Server" and v:IsA("BasePart") then
            aplicarCoinESP(v)
        end
    end
    -- Detecta novas moedas via evento
    coinESPConnection = functions.createconnection("CoinESP_Added", workspace.DescendantAdded, function(new)
        if espConfig.coinEnabled and new.Name == "Coin_Server" and new:IsA("BasePart") then
            aplicarCoinESP(new)
        end
    end)
end

local function disableCoinESP()
    espConfig.coinEnabled = false
    functions.closeconnection("CoinESP_Added")
    coinESPConnection = nil
    for _, v in pairs(workspace:GetDescendants()) do
        if v:FindFirstChild("Coin_XRAY") then v.Coin_XRAY:Destroy() end
    end
end

-- ==================== NOCLIP ====================

local function startNoClip()
    noclipActive = true
    
    functions.createconnection("NoClip", "Stepped", function()
        if not noclipActive then return end
        
        local char = game.Players.LocalPlayer.Character
        if not char then return end
        
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end)
end

local function stopNoClip()
    noclipActive = false
    functions.closeconnection("NoClip")
    
    local char = game.Players.LocalPlayer.Character
    if char then
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

-- ==================== SPEED & JUMP ====================

local function setSpeed(value)
    MY_SPEED = value
    
    local char = game.Players.LocalPlayer.Character
    if char then
        local humanoid = char:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = value
        end
    end
end

local function setJump(value)
    MY_JUMP = value
    
    local char = game.Players.LocalPlayer.Character
    if char then
        local humanoid = char:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.JumpPower = value
        end
    end
end

-- Monitora quando o jogo reseta WalkSpeed/JumpPower (ex: MM2 reseta ao puxar faca)
-- e reaplica imediatamente os valores configurados
local speedWatchConn = nil
local jumpWatchConn  = nil

local function hookHumanoidStats(humanoid)
    if speedWatchConn then speedWatchConn:Disconnect() end
    if jumpWatchConn  then jumpWatchConn:Disconnect()  end

    speedWatchConn = humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
        if MY_SPEED ~= 16 and humanoid.WalkSpeed ~= MY_SPEED then
            humanoid.WalkSpeed = MY_SPEED
        end
    end)
    jumpWatchConn = humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
        if MY_JUMP ~= 50 and humanoid.JumpPower ~= MY_JUMP then
            humanoid.JumpPower = MY_JUMP
        end
    end)
end

-- ==================== ANTI-AFK ====================

local antiAFKActive = false
local antiAFKConnection = nil

local function startAntiAFK()
    antiAFKActive = true
    local VU = game:GetService("VirtualUser")
    antiAFKConnection = game.Players.LocalPlayer.Idled:Connect(function()
        VU:CaptureController()
        VU:ClickButton2(Vector2.new())
    end)
end

local function stopAntiAFK()
    antiAFKActive = false
    if antiAFKConnection then
        antiAFKConnection:Disconnect()
        antiAFKConnection = nil
    end
end

-- ==================== CONFIGURAÇÃO DAS ABAS ====================

-- ==================== SHERIFF TAB ====================
do
    sheriffTab:AddSection("Shot Configuration")

    sheriffTab:AddKeybind("AutoShotKeybind", {
        Title = "Auto Shot Hotkey",
        Description = "Press to shoot once",
        Default = "E",
        Callback = function()
            local success, errorMsg = pcall(function()
                Atirar()
            end)
            
            if not success then
                warn("Hotkey Shot Error:", errorMsg)
            end
        end
    })
    
    sheriffTab:AddDropdown("ShotSpeed", {
        Title = "Shot Speed",
        Description = "Change fire rate delay",
        Values = {"Fast", "Medium", "Slow"},
        Default = "Medium",
        Callback = function(value)
            if value == "Fast" then
                delayTiro = 0.15
            elseif value == "Medium" then
                delayTiro = 0.3
            else
                delayTiro = 0.5
            end
        end
    })
    
    sheriffTab:AddToggle("UnequipAfterShot", {
        Title = "Unequip After Shot",
        Description = "Auto-unequip weapon after shooting",
        Default = false,
        Callback = function(value)
            sheriffConfig.UnequipAfterShot = value
        end
    })
    
    sheriffTab:AddSlider("HolsterDelay", {
        Title = "Holster Delay",
        Description = "Delay before unequipping (seconds)",
        Default = 0.0,
        Min = 0.0,
        Max = 2.0,
        Rounding = 2,
        Callback = function(value)
            delayHolster = value
        end
    })
    
    sheriffTab:AddSection("On-Screen Button")
    
    sheriffTab:AddToggle("ShowButton", {
        Title = "Show Auto Shot Button",
        Description = "Display button on screen to shoot",
        Default = false,
        Callback = function(value)
            sheriffConfig.showButton = value
            if value then
                CriarBotaoTela()
            else
                RemoverBotaoTela()
            end
        end
    })
    
    sheriffTab:AddToggle("DraggableButton", {
        Title = "Draggable Button",
        Description = "Enable to move the button around",
        Default = false,
        Callback = function(value)
            botaoArrastavel = value
        end
    })
    
    sheriffTab:AddSlider("ButtonSize", {
        Title = "Button Size",
        Description = "Adjust the button size",
        Default = 80,
        Min = 50,
        Max = 150,
        Rounding = 0,
        Callback = function(value)
            tamanhoBot = value
            AtualizarTamanhoBotao()
        end
    })
    
    sheriffTab:AddSection("Advanced Targeting")
    
    sheriffTab:AddToggle("WallCheck", {
        Title = "Wall Check",
        Description = "Only shoot if target is visible (no walls blocking)",
        Default = false,
        Callback = function(value)
            autoShotConfig.wallCheck = value
        end
    })
    
    sheriffTab:AddSection("Prediction Settings")

    sheriffTab:AddToggle("PingPrediction", {
        Title = "Ping Prediction",
        Description = "Compensate for network latency",
        Default = true,
        Callback = function(value)
            sheriffConfig.PingPrediction = value
        end
    })

    sheriffTab:AddSlider("PingSensitivity", {
        Title = "Ping Sensitivity",
        Description = "Adjust ping compensation",
        Default = 1.18,
        Min = 0.5,
        Max = 2.0,
        Rounding = 2,
        Callback = function(value)
            sheriffConfig.PingSensitivity = value
        end
    })

    sheriffTab:AddToggle("JumpPrediction", {
        Title = "Jump Prediction",
        Description = "Compensate when target is airborne",
        Default = true,
        Callback = function(value)
            sheriffConfig.JumpPrediction = value
        end
    })

    sheriffTab:AddSlider("HorizontalMultiplier", {
        Title = "Horizontal Multiplier",
        Description = "Adjust horizontal prediction strength",
        Default = 1.00,
        Min = 0.1,
        Max = 2.0,
        Rounding = 2,
        Callback = function(value)
            sheriffConfig.HorizontalMultiplier = value
        end
    })

    sheriffTab:AddSlider("VerticalMultiplier", {
        Title = "Vertical Multiplier",
        Description = "Adjust vertical prediction strength",
        Default = 1.00,
        Min = 0.1,
        Max = 2.0,
        Rounding = 2,
        Callback = function(value)
            sheriffConfig.VerticalMultiplier = value
        end
    })

    sheriffTab:AddSlider("LeadTime", {
        Title = "Lead Time",
        Description = "Base prediction time (seconds)",
        Default = 0.05,
        Min = 0.05,
        Max = 0.30,
        Rounding = 2,
        Callback = function(value)
            sheriffConfig.LeadTime = value
        end
    })

    sheriffTab:AddSlider("VerticalDistanceScale", {
        Title = "Vertical Distance Scale",
        Description = "Vertical adjustment for long range",
        Default = 2.00,
        Min = 1,
        Max = 20,
        Rounding = 2,
        Callback = function(value)
            sheriffConfig.VerticalDistanceScale = value
        end
    })

    sheriffTab:AddSlider("MaxDistance", {
        Title = "Max Prediction Distance",
        Description = "Maximum distance for prediction",
        Default = 350,
        Min = 100,
        Max = 500,
        Rounding = 0,
        Callback = function(value)
            sheriffConfig.MaxPredictionDistance = value
        end
    })

    sheriffTab:AddSlider("XMultiplier", {
        Title = "X Multiplier",
        Description = "Fine-tune X axis offset",
        Default = 0.00,
        Min = -1.0,
        Max = 1.0,
        Rounding = 2,
        Callback = function(value)
            sheriffConfig.XMultiplier = value
        end
    })

    sheriffTab:AddSlider("ZMultiplier", {
        Title = "Z Multiplier",
        Description = "Fine-tune Z axis offset",
        Default = 0.00,
        Min = -1.0,
        Max = 1.0,
        Rounding = 2,
        Callback = function(value)
            sheriffConfig.ZMultiplier = value
        end
    })
end

-- ==================== MURDER TAB ====================
do
    murderTab:AddSection("Murder Tools")
    
    murderTab:AddSection("Hitbox Expander")
    
    murderTab:AddToggle("ExpandHitbox", {
        Title = "Expand Hitboxes",
        Description = "Enlarge player hitboxes for easier hits",
        Default = false,
        Callback = function(value)
            hitboxConfig.enabled = value
            if value then
                startHitbox()
            else
                stopHitbox()
            end
        end
    })
    
    murderTab:AddSlider("HitboxSize", {
        Title = "Hitbox Size",
        Description = "Size of the expanded hitbox",
        Default = 10,
        Min = 5,
        Max = 50,
        Rounding = 0,
        Callback = function(value)
            hitboxConfig.size = value
        end
    })
    
    murderTab:AddToggle("ShowHitbox", {
        Title = "Show Hitbox ESP",
        Description = "Display visual box around expanded hitbox",
        Default = true,
        Callback = function(value)
            hitboxConfig.visible = value
        end
    })
    
    murderTab:AddSlider("HitboxTransparency", {
        Title = "Hitbox Transparency",
        Description = "0 = solid, 1 = invisible",
        Default = 0.5,
        Min = 0.0,
        Max = 1.0,
        Rounding = 2,
        Callback = function(value)
            hitboxConfig.transparency = value
        end
    })
    
    murderTab:AddColorpicker("HitboxColor", {
        Title = "Hitbox Color",
        Description = "Color of the hitbox visualization",
        Default = Color3.fromRGB(255, 0, 80),
        Callback = function(value)
            hitboxConfig.color = value
        end
    })
    
    murderTab:AddParagraph({
        Title = "How it works",
        Content = "Creates an invisible expanded hitbox around players that detects hits. Visual box shows the hitbox area."
    })
end

-- ==================== PLAYER TAB ====================
do
    playerTab:AddSection("Movement")
    
    playerTab:AddSlider("Speed", {
        Title = "Walk Speed",
        Description = "Change your walk speed",
        Default = 16,
        Min = 16,
        Max = 200,
        Rounding = 0,
        Callback = function(value)
            setSpeed(value)
        end
    })
    
    playerTab:AddSlider("Jump", {
        Title = "Jump Power",
        Description = "Change your jump power",
        Default = 50,
        Min = 50,
        Max = 200,
        Rounding = 0,
        Callback = function(value)
            setJump(value)
        end
    })
    
    playerTab:AddSection("Abilities")
    
    playerTab:AddToggle("NoClip", {
        Title = "No Clip",
        Description = "Walk through walls",
        Default = false,
        Callback = function(value)
            if value then
                startNoClip()
            else
                stopNoClip()
            end
        end
    })
end

-- ==================== VISUAL TAB ====================
do
    visualTab:AddSection("ESP Settings")
    
    local ToggleESP = visualTab:AddToggle("PlayerESP", {
        Title = "Player ESP",
        Description = "See players through walls with highlights",
        Default = false
    })
    
    ToggleESP:OnChanged(function(value)
        if value then
            enablePlayerESP()
        else
            disablePlayerESP()
        end
    end)
    
    visualTab:AddSection("ESP Name Settings")
    
    local ToggleName = visualTab:AddToggle("ESPName", {
        Title = "Show Name",
        Description = "Display player names above them",
        Default = true
    })
    
    ToggleName:OnChanged(function(value)
        espConfig.nameEnabled = value
    end)
    
    visualTab:AddSlider("NameSize", {
        Title = "Name Size",
        Description = "Adjust the text size of names",
        Default = 14,
        Min = 10,
        Max = 30,
        Rounding = 0,
        Callback = function(value)
            espConfig.nameSize = value
        end
    })
    
    visualTab:AddSection("ESP Colors")
    
    visualTab:AddColorpicker("InnocentColor", {
        Title = "Innocent Color",
        Description = "Color for innocent players",
        Default = Color3.fromHex("#00ff00"),
        Callback = function(value)
            espConfig.innocentColor = value
        end
    })
    
    visualTab:AddColorpicker("SheriffColor", {
        Title = "Sheriff Color",
        Description = "Color for sheriff player",
        Default = Color3.fromHex("#0026ff"),
        Callback = function(value)
            espConfig.sheriffColor = value
        end
    })
    
    visualTab:AddColorpicker("MurdererColor", {
        Title = "Murderer Color",
        Description = "Color for murderer player",
        Default = Color3.fromHex("#ff0000"),
        Callback = function(value)
            espConfig.murdererColor = value
        end
    })
    
    visualTab:AddParagraph({
        Title = "ESP Info",
        Content = "ESP highlights players with colored outlines. Green = Innocent, Blue = Sheriff, Red = Murderer. Customize colors and name display to your preference."
    })

    visualTab:AddSection("Item ESP")

    visualTab:AddParagraph({
        Title = "Item ESP",
        Content = "Show dropped guns and coins on the map through walls."
    })

    local ToggleGunESP = visualTab:AddToggle("GunESP", {
        Title = "Gun ESP",
        Description = "Highlight dropped guns on the map",
        Default = false
    })

    ToggleGunESP:OnChanged(function(value)
        espConfig.gunEnabled = value
        if value then
            enableGunESP()
        else
            disableGunESP()
        end
    end)

    local ToggleCoinESP = visualTab:AddToggle("CoinESP", {
        Title = "Coin ESP",
        Description = "Highlight coins on the map",
        Default = false
    })

    ToggleCoinESP:OnChanged(function(value)
        espConfig.coinEnabled = value
        if value then
            enableCoinESP()
        else
            disableCoinESP()
        end
    end)
end

-- ==================== AUTO FARM TAB ====================
do
    autoFarmTab:AddSection("Auto Farm")
    
    autoFarmTab:AddToggle("AntiAFK", {
        Title = "Anti-AFK",
        Description = "Prevent being kicked for inactivity",
        Default = false,
        Callback = function(value)
            if value then
                startAntiAFK()
            else
                stopAntiAFK()
            end
        end
    })
    
    autoFarmTab:AddParagraph({
        Title = "Info",
        Content = "Anti-AFK keeps you in the game by simulating activity."
    })
end

-- ==================== CONFIGURAÇÃO FINAL ====================

-- Sistema de reset quando personagem spawna (nova rodada)
game.Players.LocalPlayer.CharacterAdded:Connect(function(character)
    -- Aguarda o personagem carregar completamente
    task.wait(0.5)
    
    -- Reseta estado de tiro
    podeAtirar = true
    
    -- Limpa histórico de velocidade e aceleração
    velocityHistory = {}
    accelerationHistory = {}
    
    -- Aguarda o Humanoid carregar
    local humanoid = character:WaitForChild("Humanoid", 5)
    if humanoid then
        -- Reaplica velocidade e jump power
        if MY_SPEED ~= 16 then
            humanoid.WalkSpeed = MY_SPEED
        end
        if MY_JUMP ~= 50 then
            humanoid.JumpPower = MY_JUMP
        end
        -- Monitora resets do jogo (ex: MM2 reseta WalkSpeed ao puxar faca)
        hookHumanoidStats(humanoid)
    end
    
    -- Recria botão se estiver habilitado
    if sheriffConfig.showButton and not botaoTela then
        task.wait(0.5)
        CriarBotaoTela()
    end
end)

-- Garante que o estado inicial está correto
podeAtirar = true

-- Hook inicial: se o personagem já existe quando o script carrega
local _initChar = game.Players.LocalPlayer.Character
if _initChar then
    local _initHum = _initChar:FindFirstChild("Humanoid")
    if _initHum then hookHumanoidStats(_initHum) end
end

-- SaveManager e InterfaceManager
GUI.SaveManager:SetFolder("moon")
GUI.SaveManager:SetFolder("moon/mm2")
GUI.InterfaceManager:SetLibrary(GUI)
GUI.InterfaceManager:BuildInterfaceSection(settingsTab)
GUI.SaveManager:IgnoreThemeSettings()
GUI.SaveManager:SetLibrary(GUI)
GUI.SaveManager:BuildConfigSection(settingsTab)
GUI.SaveManager:LoadAutoloadConfig()
